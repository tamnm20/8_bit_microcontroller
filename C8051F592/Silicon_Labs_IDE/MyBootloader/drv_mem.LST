C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE DRV_MEM
OBJECT MODULE PLACED IN drv_mem.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe drv_mem.c DB OE BR INTVECTOR(0X90) INTERVAL(3) LARGE NOAREGS DEBUG OBJECTEX
                    -TEND SB DF(CLK_FREQUENCY=24,C_DERIVATIVE_C8051F5x) OR CD LC LARGE OT(5,SPEED) INCDIR(c:\SiLabs\MCU\Inc;D:\FPM_Tools\mico
                    -m_diag\mcnex_diagnostic\CANGEN_MCNEX;D:\FPM_Tools\micom_diag\mcnex_diagnostic\CanBSW)

line level    source

   1          /*_____ I N C L U D E __________________________________________*/
   2          #include "compiler_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // compiler_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Portions of this file are copyright Maarten Brock
   5      =1  // http://sdcc.sourceforge.net
   6      =1  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =1  // http://www.silabs.com
   8      =1  //
   9      =1  // GNU LGPL boilerplate:
  10      =1  /** This library is free software; you can redistribute it and/or
  11      =1    * modify it under the terms of the GNU Lesser General Public
  12      =1    * License as published by the Free Software Foundation; either
  13      =1    * version 2.1 of the License, or (at your option) any later version.
  14      =1    *
  15      =1    * This library is distributed in the hope that it will be useful,
  16      =1    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =1    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =1    * Lesser General Public License for more details.
  19      =1    *
  20      =1    * You should have received a copy of the GNU Lesser General Public
  21      =1    * License along with this library; if not, write to the Free Software
  22      =1    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =1    *
  24      =1    * In other words, you are welcome to use, share and improve this program.
  25      =1    * You are forbidden to forbid anyone else to use, share and improve
  26      =1    * what you give them. Help stamp out software-hoarding!
  27      =1  **/
  28      =1  // Program Description:
  29      =1  //
  30      =1  // **Important Note**: This header file should be included before including
  31      =1  // a device-specific header file such as C8051F300_defs.h.
  32      =1  //
  33      =1  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =1  // special function registers and other 8051-specific features such as NOP
  35      =1  // generation, and locating variables in memory-specific segments.  The
  36      =1  // compilers are identified by their unique predefined macros. See also:
  37      =1  // http://predef.sourceforge.net/precomp.html
  38      =1  //
  39      =1  // SBIT and SFR define special bit and special function registers at the given
  40      =1  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =1  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =1  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =1  // combinations will guarantee the order in which they are accessed when read
  44      =1  // or written.
  45      =1  //
  46      =1  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =1  // to avoid portability issues because of compiler endianness.
  48      =1  //
  49      =1  // Example:
  50      =1  // // my_mcu.c: main 'c' file for my mcu
  51      =1  // #include <compiler_defs.h>  // this file
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 2   

  52      =1  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =1  //
  54      =1  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =1  // SFR   (P0, 0x80);           // Port 0
  56      =1  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =1  //                             // xdata memory at 0xE600
  58      =1  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =1  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =1  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =1  //                             // lsb at 0x93, msb at 0x96
  62      =1  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =1  //                             // lsb at 0xE2, msb at 0xE5
  64      =1  //
  65      =1  // Target:         C8051xxxx
  66      =1  // Tool chain:     Generic
  67      =1  // Command Line:   None
  68      =1  // 
  69      =1  // Release 2.6 - 14 DEC 2012 (GO)
  70      =1  //        -Added define for deprecated SDCC keyword 'at'
  71      =1  // Release 2.5 - 12 SEP 2012 (TP)
  72      =1  //    -Added defines for deprecated SDCC keywords bit and code
  73      =1  // Release 2.4 - 27 AUG 2012 (TP)
  74      =1  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =1  // Release 2.3 - 27 MAY 2010 (DM)
  76      =1  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =1  // Release 2.2 - 06 APR 2010 (ES)
  78      =1  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =1  // Release 2.1 - 16 JUL 2009 (ES)
  80      =1  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =1  // Release 2.0 - 19 MAY 2009 (ES)
  83      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =1  // Release 1.9 - 23 OCT 2008 (ES)
  85      =1  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =1  //    -Added SFR16 macro defintion for Hi-Tech
  87      =1  // Release 1.8 - 31 JUL 2008 (ES)
  88      =1  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =1  //    -Added macro's for IAR
  90      =1  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =1  // Release 1.7 - 11 SEP 2007 (BW)
  92      =1  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =1  // Release 1.6 - 27 AUG 2007 (BW)
  94      =1  //    -Updated copyright notice per agreement with Maartin Brock
  95      =1  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =1  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =1  // Release 1.5 - 24 AUG 2007 (BW)
  98      =1  //    -Added support for NOP () macro
  99      =1  //    -Added support for Hi-Tech ver 9.01
 100      =1  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =1  //    -Removed FID and fixed formatting.
 102      =1  // Release 1.3 - 30 SEP 2007 (TP)
 103      =1  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =1  //     under SDCC.
 105      =1  // Release 1.2 - (BW)
 106      =1  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =1  // Release 1.1 - (BW)
 108      =1  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =1  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =1  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =1  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =1  //    -Initial revision
 113      =1  
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 3   

 114      =1  //-----------------------------------------------------------------------------
 115      =1  // Header File Preprocessor Directive
 116      =1  //-----------------------------------------------------------------------------
 117      =1  
 118      =1  #ifndef COMPILER_DEFS_H
 119      =1  #define COMPILER_DEFS_H
 120      =1  
 121      =1  //-----------------------------------------------------------------------------
 122      =1  // Macro definitions
 123      =1  //-----------------------------------------------------------------------------
 124      =1  
 125      =1  // SDCC - Small Device C Compiler
 126      =1  // http://sdcc.sourceforge.net
 127      =1  
 128      =1  #if defined SDCC
           =1 
           =1 #if (SDCC >= 300)
           =1 
           =1 #define interrupt __interrupt
           =1 #define _asm __asm
           =1 #define _endasm __endasm
           =1 #define bit __bit
           =1 #define code __code
           =1 #define at __at
           =1 
           =1 #endif
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   __xdata
           =1 # define SEG_DATA  __data
           =1 # define SEG_NEAR  __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =1 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =1 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =1 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =1 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =1 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =1 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 4   

           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() _asm NOP _endasm
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Raisonance (must be placed before Keil C51)
           =1 // http://www.raisonance.com
           =1 
           =1 #elif defined __RC51__
           =1 
           =1 //#error Raisonance C51 detected.
           =1 
           =1 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =1 # define SEG_FAR   xdata
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  data
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 5   

           =1 
           =1 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =1 # define SFR(name, addr)        sfr at addr                name
           =1 # define SFR16(name, addr)      sfr16 at addr              name
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO(name, vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =1 
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 6   

           =1 
           =1 // NOP () macro support -- NOP is opcode 0x00
           =1 #define NOP() asm { 0x00 }
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // Keil C51
           =1 // http://www.keil.com
           =1 
           =1 #elif defined __C51__
 307      =1  
 308      =1  //#error Keil C51 detected.
 309      =1  
 310      =1  # define SEG_GENERIC
 311      =1  # define SEG_FAR   xdata
 312      =1  # define SEG_DATA  data
 313      =1  # define SEG_NEAR  data
 314      =1  # define SEG_IDATA idata
 315      =1  # define SEG_XDATA xdata
 316      =1  # define SEG_PDATA pdata
 317      =1  # define SEG_CODE  code
 318      =1  # define SEG_BDATA bdata
 319      =1  
 320      =1  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 321      =1  # define SFR(name, addr)        sfr   name = addr
 322      =1  # define SFR16(name, addr)      sfr16 name = addr
 323      =1  # define SFR16E(name, fulladdr) /* not supported */
 324      =1  # define SFR32(name, fulladdr)  /* not supported */
 325      =1  # define SFR32E(name, fulladdr) /* not supported */
 326      =1  
 327      =1  # define INTERRUPT(name, vector) void name (void) interrupt vector
 328      =1  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 329      =1  # define INTERRUPT_PROTO(name, vector) void name (void)
 330      =1  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 331      =1  
 332      =1  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
 333      =1  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 334      =1  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 335      =1  
 336      =1  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 337      =1  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 338      =1  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 339      =1  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 340      =1  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 341      =1  
 342      =1  // used with UU16
 343      =1  # define LSB 1
 344      =1  # define MSB 0
 345      =1  
 346      =1  // used with UU32 (b0 is least-significant byte)
 347      =1  //# define b0 3
 348      =1  // define b1 2
 349      =1  //# define b2 1
 350      =1  //# define b3 0
 351      =1  
 352      =1  typedef unsigned char U8;
 353      =1  typedef unsigned int U16;
 354      =1  typedef unsigned long U32;
 355      =1  
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 7   

 356      =1  typedef signed char S8;
 357      =1  typedef signed int S16;
 358      =1  typedef signed long S32;
 359      =1  
 360      =1  typedef union UU16
 361      =1  {
 362      =1     U16 U16;
 363      =1     S16 S16;
 364      =1     U8 U8[2];
 365      =1     S8 S8[2];
 366      =1  } UU16;
 367      =1  
 368      =1  typedef union UU32
 369      =1  {
 370      =1     U32 U32;
 371      =1     S32 S32;
 372      =1     UU16 UU16[2];
 373      =1     U16 U16[2];
 374      =1     S16 S16[2];
 375      =1     U8 U8[4];
 376      =1     S8 S8[4];
 377      =1  } UU32;
 378      =1  
 379      =1  // NOP () macro support
 380      =1  extern void _nop_ (void);
 381      =1  #define NOP() _nop_()
 382      =1  
 383      =1  //-----------------------------------------------------------------------------
 384      =1  
 385      =1  // Hi-Tech 8051
 386      =1  // http://www.htsoft.com
 387      =1  
 388      =1  #elif defined HI_TECH_C
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   far
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  near
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
           =1 
           =1 
           =1 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =1 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =1 # define INTERRUPT_PROTO(name, vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: Hi-Tech does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 8   

           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 0
           =1 # define b1 1
           =1 # define b2 2
           =1 # define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() asm(" nop ")
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Tasking / Altium
           =1 // http://www.altium.com/tasking
           =1 
           =1 
           =1 #elif defined _CC51
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   _xdat
           =1 # define SEG_DATA  _data
           =1 # define SEG_NEAR  _data
           =1 # define SEG_IDATA _idat
           =1 # define SEG_XDATA _xdat
           =1 # define SEG_PDATA _pdat
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 9   

           =1 # define SEG_CODE  _rom
           =1 # define SEG_BDATA _bdat
           =1 
           =1 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =1 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =1 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =1 #if _CC51 > 71
           =1 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =1 #else
           =1 # define SFR16(name, addr)      /* not supported */
           =1 #endif
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 
           =1 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =1 // is also using the same register bank. If not, the compiler will generate an error.
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 10  

           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 extern void _nop (void);
           =1 #define NOP() _nop()
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // IAR 8051
           =1 // http://www.iar.com
           =1 
           =1 #elif defined __ICC8051__
           =1 
           =1 #include <stdbool.h>
           =1 #include <intrinsics.h>
           =1 
           =1 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =1 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =1 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr) /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define SEG_GENERIC __generic
           =1 # define SEG_FAR  __xdata
           =1 # define SEG_DATA __data
           =1 # define SEG_NEAR __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 #define bit bool
           =1 
           =1 # define _PPTOSTR_(x) #x
           =1 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =1 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =1 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =1 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: IAR does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 11  

             -csegment name
           =1 
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 
           =1 #define NOP() __no_operation();
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Crossware
           =1 // http://www.crossware.com
           =1 
           =1 #elif defined _XC51_VER
           =1 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =1 # define SFR(name, addr)        _sfr     name = addr
           =1 # define SFR16(name, addr)      _sfrword name = addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Wickenhäuser
           =1 // http://www.wickenhaeuser.de
           =1 
           =1 #elif defined __UC__
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 12  

           =1 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =1 # define SFR(name, addr)        near unsigned char name @ addr
           =1 # define SFR16(name, addr)      /* not supported */
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Default
           =1 // Unknown compiler
           =1 
           =1 #else
           =1 # warning unrecognized compiler
           =1 # define SBIT(name, addr, bit)  volatile bool           name
           =1 # define SFR(name, addr)        volatile unsigned char  name
           =1 # define SFRX(name, addr)       volatile unsigned char  name
           =1 # define SFR16(name, addr)      volatile unsigned short name
           =1 # define SFR16E(name, fulladdr) volatile unsigned short name
           =1 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =1 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =1 
           =1 #endif
 683      =1  
 684      =1  //-----------------------------------------------------------------------------
 685      =1  // Header File PreProcessor Directive
 686      =1  //-----------------------------------------------------------------------------
 687      =1  
 688      =1  #endif                                 // #define COMPILER_DEFS_H
 689      =1  
 690      =1  //-----------------------------------------------------------------------------
 691      =1  // End Of File
 692      =1  //-----------------------------------------------------------------------------
   3          #include "C8051F580_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // C8051F580_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Copyright 2008, Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Register/bit definitions for the C8051F58x family.
  10      =1  // **Important Note**: The compiler_defs.h header file should be included
  11      =1  // before including this header file.
  12      =1  //
  13      =1  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =1  // Tool chain:     Generic
  15      =1  // Command Line:   None
  16      =1  //
  17      =1  // Release 0.6 - 20 AUG 2012 (TP)
  18      =1  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =1  //     (pdata)
  20      =1  //
  21      =1  // Release 0.5 - 10 SEP 2011 (GP)
  22      =1  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =1  //
  24      =1  // Release 0.4 - 08 OCT 2010 (TP)
  25      =1  //    - Fixed bit definitions for SCON0
  26      =1  //
  27      =1  // Release 0.3 - 01 APR 2009 (GP)
  28      =1  //    - Added SN0-SN3
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 13  

  29      =1  //
  30      =1  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =1  //    - Added Timer 4 bit definitions
  32      =1  //
  33      =1  // Release 0.1 - 09 JUL 2008 (GP)
  34      =1  //    - Initial Revision
  35      =1  //
  36      =1  //-----------------------------------------------------------------------------
  37      =1  // Header File Preprocessor Directive
  38      =1  //-----------------------------------------------------------------------------
  39      =1  
  40      =1  #ifndef C8051F580_DEFS_H
  41      =1  #define C8051F580_DEFS_H
  42      =1  
  43      =1  //-----------------------------------------------------------------------------
  44      =1  // Page 0, Page 1 and Page F Registers
  45      =1  //-----------------------------------------------------------------------------
  46      =1  
  47      =1  SFR (P0, 0x80);                        // Port 0 Latch
  48      =1  SFR (SP, 0x81);                        // Stack Pointer
  49      =1  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =1  SFR (DPH, 0x83);                       // Data Pointer High
  51      =1  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =1  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =1  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =1  SFR (PCON, 0x87);                      // Power Control
  55      =1  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =1  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =1  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =1  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =1  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =1  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =1  SFR (CKCON, 0x8E);                     // Clock Control
  62      =1  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  63      =1  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =1  SFR (P1, 0x90);                        // Port 1 Latch
  65      =1  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =1  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =1  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =1  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =1  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =1  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =1  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =1  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =1  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =1  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =1  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =1  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =1  SFR (SCON0, 0x98);                     // UART0 Control
  78      =1  SFR (SCON1, 0x98);                     // UART1 Control
  79      =1  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =1  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =1  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =1  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =1  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =1  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =1  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =1  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =1  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =1  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =1  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =1  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 14  

  91      =1  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =1  SFR (P2, 0xA0);                        // Port 2 Latch
  93      =1  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =1  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =1  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =1  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =1  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =1  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =1  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =1  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =1  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =1  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =1  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =1  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =1  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =1  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =1  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =1  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =1  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =1  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =1  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =1  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =1  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =1  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =1  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =1  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =1  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =1  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =1  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =1  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =1  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =1  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =1  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
 124      =1  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
 125      =1  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =1  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =1  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =1  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =1  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =1  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =1  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =1  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =1  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =1  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =1  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =1  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =1  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =1  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =1  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =1  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =1  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =1  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =1  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =1  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =1  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =1  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =1  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =1  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =1  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =1  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =1  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =1  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 15  

 153      =1  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =1  SFR (PSW, 0xD0);                       // Program Status Word
 155      =1  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =1  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =1  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =1  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =1  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =1  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =1  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =1  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =1  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =1  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =1  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =1  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =1  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =1  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =1  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =1  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =1  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =1  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =1  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =1  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =1  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =1  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =1  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =1  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =1  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =1  SFR (ACC, 0xE0);                       // Accumulator
 181      =1  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =1  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =1  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =1  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =1  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
 186      =1  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
 187      =1  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =1  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =1  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =1  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =1  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =1  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =1  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =1  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =1  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =1  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =1  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =1  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =1  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =1  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =1  SFR (B, 0xF0);                         // B Register
 202      =1  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =1  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =1  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =1  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =1  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =1  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =1  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =1  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =1  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =1  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =1  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =1  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =1  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 16  

 215      =1  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =1  SFR (SN0, 0xF9);                       // Serial Number 0
 217      =1  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =1  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =1  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =1  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =1  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =1  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =1  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =1  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =1  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =1  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =1  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =1  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =1  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =1  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =1  
 232      =1  //-----------------------------------------------------------------------------
 233      =1  // Page C (CAN0) Registers
 234      =1  //-----------------------------------------------------------------------------
 235      =1  
 236      =1  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =1  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =1  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =1  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =1  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =1  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =1  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =1  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =1  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =1  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =1  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =1  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
 248      =1  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
 249      =1  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =1  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =1  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =1  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =1  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =1  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =1  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =1  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =1  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =1  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =1  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =1  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =1  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =1  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =1  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =1  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =1  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =1  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =1  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =1  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =1  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =1  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =1  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =1  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =1  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =1  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =1  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =1  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 17  

 277      =1  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =1  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
 279      =1  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =1  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =1  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =1  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =1  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =1  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =1  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =1  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =1  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =1  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =1  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =1  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =1  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =1  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =1  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =1  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =1  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =1  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =1  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =1  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =1  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =1  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =1  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =1  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =1  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =1  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =1  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =1  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =1  
 308      =1  
 309      =1  //-----------------------------------------------------------------------------
 310      =1  // 16-bit Register Definitions (might not be supported by all compilers)
 311      =1  //-----------------------------------------------------------------------------
 312      =1  
 313      =1  SFR16 (DP, 0x82);                      // Data Pointer
 314      =1  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =1  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =1  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =1  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =1  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =1  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =1  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =1  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =1  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =1  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =1  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =1  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =1  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =1  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =1  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =1  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =1  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =1  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =1  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =1  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =1  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =1  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =1  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =1  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =1  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 18  

 339      =1  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =1  
 341      =1  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =1  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =1  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =1  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =1  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =1  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =1  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =1  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =1  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =1  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =1  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =1  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =1  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =1  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =1  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =1  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =1  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =1  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =1  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =1  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =1  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =1  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =1  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =1  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =1  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =1  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =1  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =1  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =1  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =1  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =1  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
 372      =1  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
 373      =1  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =1  
 375      =1  //-----------------------------------------------------------------------------
 376      =1  // LIN0 Indirect Registers
 377      =1  //-----------------------------------------------------------------------------
 378      =1  
 379      =1  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =1  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =1  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =1  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =1  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =1  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =1  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =1  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =1  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =1  #define  LIN0ST    0x09                // LIN0 Status
 389      =1  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =1  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =1  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =1  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =1  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =1  
 395      =1  //-----------------------------------------------------------------------------
 396      =1  // Address Definitions for Bit-addressable Registers
 397      =1  //-----------------------------------------------------------------------------
 398      =1  
 399      =1  #define SFR_P0       0x80
 400      =1  #define SFR_TCON     0x88
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 19  

 401      =1  #define SFR_P1       0x90
 402      =1  #define SFR_SCON0    0x98
 403      =1  #define SFR_SCON1    0x98
 404      =1  #define SFR_P2       0xA0
 405      =1  #define SFR_IE       0xA8
 406      =1  #define SFR_P3       0xB0
 407      =1  #define SFR_IP       0xB8
 408      =1  #define SFR_SMB0CN   0xC0
 409      =1  #define SFR_TMR2CN   0xC8
 410      =1  #define SFR_TMR4CN   0xC8
 411      =1  #define SFR_PSW      0xD0
 412      =1  #define SFR_PCA0CN   0xD8
 413      =1  #define SFR_PCA1CN   0xD8
 414      =1  #define SFR_ACC      0xE0
 415      =1  #define SFR_ADC0CN   0xE8
 416      =1  #define SFR_B        0xF0
 417      =1  #define SFR_SPI0CN   0xF8
 418      =1  
 419      =1  //-----------------------------------------------------------------------------
 420      =1  // Bit Definitions
 421      =1  //-----------------------------------------------------------------------------
 422      =1  
 423      =1  // TCON 0x88
 424      =1  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =1  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =1  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =1  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =1  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =1  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =1  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =1  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =1  
 433      =1  // SCON0 0x98
 434      =1  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
 435      =1  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =1  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =1  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =1  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =1  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =1  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =1  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =1  
 443      =1  // SCON1 0x98
 444      =1  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =1                                         // Bit 6 UNUSED
 446      =1  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =1  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =1  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =1  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =1  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =1  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =1  
 453      =1  // IE 0xA8
 454      =1  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =1  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =1  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =1  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =1  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =1  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =1  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =1  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =1  
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 20  

 463      =1  // IP 0xB8
 464      =1                                         // Bit 7 unused
 465      =1  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =1  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =1  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =1  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =1  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =1  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =1  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =1  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =1  
 474      =1  // SMB0CN 0xC0
 475      =1  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =1  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =1  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =1  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =1  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =1  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =1  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =1  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =1  
 484      =1  // TMR2CN 0xC8
 485      =1  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =1  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =1  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =1  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =1  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =1  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =1  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =1  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =1  
 494      =1  // TMR4CN 0xC8
 495      =1  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
 496      =1  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
 497      =1                                         // Bit 5 unused
 498      =1                                         // Bit 4 unused
 499      =1  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =1  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =1  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =1  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =1  
 504      =1  // PSW 0xD0
 505      =1  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =1  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =1  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =1  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =1  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =1  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =1  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =1  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =1  
 514      =1  // PCA0CN 0xD8
 515      =1  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =1  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =1  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =1  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =1  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =1  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =1  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =1  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =1  
 524      =1  // PCA1CN 0xD8
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 21  

 525      =1  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =1  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
 527      =1  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =1  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =1  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =1  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =1  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =1  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =1  
 534      =1  // ADC0CN 0xE8
 535      =1  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =1  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =1  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =1  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =1  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =1  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =1  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =1  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =1  
 544      =1  // SPI0CN 0xF8
 545      =1  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =1  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =1  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =1  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =1  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =1  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =1  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =1  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =1  
 554      =1  //-----------------------------------------------------------------------------
 555      =1  // Interrupt Priorities
 556      =1  //-----------------------------------------------------------------------------
 557      =1  
 558      =1  #define INTERRUPT_INT0             0   // External Interrupt 0
 559      =1  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =1  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =1  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =1  #define INTERRUPT_UART0            4   // UART0
 563      =1  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =1  #define INTERRUPT_SPI0             6   // SPI0
 565      =1  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =1  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =1  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =1  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =1  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =1  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =1  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =1  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =1  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =1  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =1  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =1  #define INTERRUPT_UART1           18   // UART1
 577      =1  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =1  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =1  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =1  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =1  
 582      =1  
 583      =1  //-----------------------------------------------------------------------------
 584      =1  // SFR Page Definitions
 585      =1  //-----------------------------------------------------------------------------
 586      =1  
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 22  

 587      =1  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =1  #define  ACTIVE_PAGE       0x00        // Active Use Page
 589      =1  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =1  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =1  
 592      =1  //-----------------------------------------------------------------------------
 593      =1  // SDCC PDATA External Memory Paging Support
 594      =1  //-----------------------------------------------------------------------------
 595      =1  
 596      =1  #if defined SDCC
           =1 
           =1 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =1 
           =1 #endif
 601      =1  
 602      =1  //-----------------------------------------------------------------------------
 603      =1  // Header File PreProcessor Directive
 604      =1  //-----------------------------------------------------------------------------
 605      =1  
 606      =1  #endif                                 // #define C8051F580_DEFS_H
 607      =1  
 608      =1  //-----------------------------------------------------------------------------
 609      =1  // End Of File
 610      =1  //-----------------------------------------------------------------------------
   4          #include "Global_Define.h"
   1      =1  /*----------TYPE-------------------*/
   2      =1  
   3      =1  #define CAMERA
   4      =1  #define SYSCLK 24000000
   5      =1  /*----------SENSOR-----------------*/
   6      =1  
   7      =1  //      #define APTINA_126
   8      =1  //      #define APTINA_128
   9      =1          #define APTINA_AP0100                   0x03U
  10      =1          #define APTINA_ASX344                   0x04U
  11      =1  //      #define APTINA_ASX350AT
  12      =1  
  13      =1  
  14      =1  /*----------EEPROM-----------------*/
  15      =1  #define MXIC
  16      =1  //#define WINBOND
  17      =1  
  18      =1  /*----------DEVICE-----------------*/
  19      =1  //#define UART
  20      =1  #define SPI
  21      =1  #define I2C                                                     
  22      =1  #define ADC
  23      =1  #define WATCHDOG
  24      =1  #define PCA
  25      =1  #define CAN
  26      =1  
  27      =1  #define EXINTERRUPT
  28      =1  
  29      =1  /*----------I2C---------------*/        // Use Timer1
  30      =1  //#define I2C_SPEED_100KHZ                      
  31      =1  #define I2C_SPEED_400KHZ                
  32      =1  
  33      =1  /*----------WATCHDOG---------------*/
  34      =1  #define WATCHDOG_ENABLE
  35      =1  //#define WATCHDOG_32MS
  36      =1  #define WATCHDOG_400MS
  37      =1  
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 23  

  38      =1  /*----------VDDMONITOR-------------*/
  39      =1  #define VDDMONITOR_ENABLE
  40      =1  //#define VDDMONITOR_HIGH
  41      =1  #define VDDMONITOR_LOW
  42      =1  
  43      =1  /*----------TIMER-------------*/
  44      =1  //#define TIMER0                                        //Use Wait_ms()
  45      =1  //#define TIMER1                                                //Use SMBUS0
  46      =1  #define TIMER2                                          //1ms interrupt1
  47      =1  //#define TIMER3                                                //Use SMBUS0 low time out
  48      =1  //#define TIMER4                                        //1ms interrupt2
  49      =1  //#define TIMER5                                                //Use PCA0 (Watchdog)
  50      =1  
  51      =1  /*----------ETC..-----------------*/
  52      =1  #define TRUE    (U8)1
  53      =1  #define FALSE   (U8)0
  54      =1  
  55      =1  #define HIGH    (U8)1
  56      =1  #define LOW     (U8)0
  57      =1  
  58      =1  //CAN DATA
  59      =1  //#define MDPS11                                
  60      =1  //#define LANGUAGEINFO          
  61      =1  //#define HUTYPE                                
  62      =1  //#define GATEWAY                               
  63      =1  //#define NAVIONOFF                     
  64      =1  //#define G_SEL_DISP                
  65      =1  //#define CAM_REARCAMERA_REQ    
  66      =1  
  67      =1  //Operate Mode---------------------
  68      =1  #define OPERATE_STANDBY         (U8)1
  69      =1  #define OPERATE_INTERINIT       (U8)2
  70      =1  #define OPERATE_IDLE            (U8)3
  71      =1  #define OPERATE_RUNNING         (U8)4
  72      =1  
  73      =1  #define DTC_RECORD_WRITE
  74      =1  #define DTC_RECORD_CLEAR
  75      =1  
  76      =1  //Define Error
  77      =1  #define NO_ERROR                        (U8)0x00
  78      =1  #define ERROR_RX_COMM           (U8)0x01        //RX Error
  79      =1  #define ERROR_TX_COMM           (U8)0x02        //TX Error
  80      =1  
  81      =1  //#define ERROR_TX_COMM         (U8)0x02        //RX Error
  82      =1  
  83      =1  #define OPERATION_MODE_FIRMWARE    //firmware
  84      =1  //#define OPERATION_MODE_DOWNLOAD    //tuning
  85      =1  
  86      =1  //BANK SET
  87      =1  #define BANK0                           (U8)0x00
  88      =1  #define BANK1                           (U8)0x10
  89      =1  #define BANK2                           (U8)0x20
  90      =1  #define BANK3                           (U8)0x30
  91      =1  //DIAGNOSTIC TEST
  92      =1  //#define DIAG_TEST_MCU_WD_ERR
  93      =1  //#define DIAG_TEST_MCU_MC_ERR
  94      =1  //#define DIAG_TEST_ISP_FV_ERR
  95      =1  //#define DIAG_TEST_ISP_FC_ERR
  96      =1  //#define DIAG_TEST_ISP_IS_ERR
  97      =1  //#define DIAG_TEST_ISP_CM_ERR
  98      =1  //#define DIAG_TEST_ISP_IT_ERR
  99      =1  //#define DIAG_TEST_VID_OC_ERR
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 24  

 100      =1  //#define DIAG_TEST_VID_VO_ERR
 101      =1  
   5          #include "drv_mem.h"
   1      =1  /* ----- Global Define -------------------------------*/
   2      =1  
   3      =1  /*----------------------------------------------------*/
   4      =1  
   5      =1  /* ----- Global Value --------------------------------*/
   6      =1  
   7      =1  /*----------------------------------------------------*/
   8      =1  
   9      =1  /* ----- Function ------------------------------------*/
  10      =1  
  11      =1  /*----------------------------------------------------*/
  12      =1  
  13      =1  /* ----- Extern Function -----------------------------*/
  14      =1  
  15      =1  /*----------------------------------------------------*/
  16      =1  #ifndef DRV_MEM_H_
  17      =1  #define DRV_MEM_H_
  18      =1  
  19      =1  #include "compiler_defs.h"
   1      =2  //-----------------------------------------------------------------------------
   2      =2  // compiler_defs.h
   3      =2  //-----------------------------------------------------------------------------
   4      =2  // Portions of this file are copyright Maarten Brock
   5      =2  // http://sdcc.sourceforge.net
   6      =2  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =2  // http://www.silabs.com
   8      =2  //
   9      =2  // GNU LGPL boilerplate:
  10      =2  /** This library is free software; you can redistribute it and/or
  11      =2    * modify it under the terms of the GNU Lesser General Public
  12      =2    * License as published by the Free Software Foundation; either
  13      =2    * version 2.1 of the License, or (at your option) any later version.
  14      =2    *
  15      =2    * This library is distributed in the hope that it will be useful,
  16      =2    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =2    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =2    * Lesser General Public License for more details.
  19      =2    *
  20      =2    * You should have received a copy of the GNU Lesser General Public
  21      =2    * License along with this library; if not, write to the Free Software
  22      =2    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =2    *
  24      =2    * In other words, you are welcome to use, share and improve this program.
  25      =2    * You are forbidden to forbid anyone else to use, share and improve
  26      =2    * what you give them. Help stamp out software-hoarding!
  27      =2  **/
  28      =2  // Program Description:
  29      =2  //
  30      =2  // **Important Note**: This header file should be included before including
  31      =2  // a device-specific header file such as C8051F300_defs.h.
  32      =2  //
  33      =2  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =2  // special function registers and other 8051-specific features such as NOP
  35      =2  // generation, and locating variables in memory-specific segments.  The
  36      =2  // compilers are identified by their unique predefined macros. See also:
  37      =2  // http://predef.sourceforge.net/precomp.html
  38      =2  //
  39      =2  // SBIT and SFR define special bit and special function registers at the given
  40      =2  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 25  

  41      =2  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =2  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =2  // combinations will guarantee the order in which they are accessed when read
  44      =2  // or written.
  45      =2  //
  46      =2  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =2  // to avoid portability issues because of compiler endianness.
  48      =2  //
  49      =2  // Example:
  50      =2  // // my_mcu.c: main 'c' file for my mcu
  51      =2  // #include <compiler_defs.h>  // this file
  52      =2  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =2  //
  54      =2  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =2  // SFR   (P0, 0x80);           // Port 0
  56      =2  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =2  //                             // xdata memory at 0xE600
  58      =2  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =2  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =2  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =2  //                             // lsb at 0x93, msb at 0x96
  62      =2  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =2  //                             // lsb at 0xE2, msb at 0xE5
  64      =2  //
  65      =2  // Target:         C8051xxxx
  66      =2  // Tool chain:     Generic
  67      =2  // Command Line:   None
  68      =2  // 
  69      =2  // Release 2.6 - 14 DEC 2012 (GO)
  70      =2  //        -Added define for deprecated SDCC keyword 'at'
  71      =2  // Release 2.5 - 12 SEP 2012 (TP)
  72      =2  //    -Added defines for deprecated SDCC keywords bit and code
  73      =2  // Release 2.4 - 27 AUG 2012 (TP)
  74      =2  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =2  // Release 2.3 - 27 MAY 2010 (DM)
  76      =2  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =2  // Release 2.2 - 06 APR 2010 (ES)
  78      =2  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =2  // Release 2.1 - 16 JUL 2009 (ES)
  80      =2  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =2  // Release 2.0 - 19 MAY 2009 (ES)
  83      =2  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =2  // Release 1.9 - 23 OCT 2008 (ES)
  85      =2  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =2  //    -Added SFR16 macro defintion for Hi-Tech
  87      =2  // Release 1.8 - 31 JUL 2008 (ES)
  88      =2  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =2  //    -Added macro's for IAR
  90      =2  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =2  // Release 1.7 - 11 SEP 2007 (BW)
  92      =2  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =2  // Release 1.6 - 27 AUG 2007 (BW)
  94      =2  //    -Updated copyright notice per agreement with Maartin Brock
  95      =2  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =2  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =2  // Release 1.5 - 24 AUG 2007 (BW)
  98      =2  //    -Added support for NOP () macro
  99      =2  //    -Added support for Hi-Tech ver 9.01
 100      =2  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =2  //    -Removed FID and fixed formatting.
 102      =2  // Release 1.3 - 30 SEP 2007 (TP)
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 26  

 103      =2  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =2  //     under SDCC.
 105      =2  // Release 1.2 - (BW)
 106      =2  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =2  // Release 1.1 - (BW)
 108      =2  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =2  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =2  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =2  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =2  //    -Initial revision
 113      =2  
 114      =2  //-----------------------------------------------------------------------------
 115      =2  // Header File Preprocessor Directive
 116      =2  //-----------------------------------------------------------------------------
 117      =2  
 118      =2  #ifndef COMPILER_DEFS_H
           =2 #define COMPILER_DEFS_H
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Macro definitions
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // SDCC - Small Device C Compiler
           =2 // http://sdcc.sourceforge.net
           =2 
           =2 #if defined SDCC
           =2 
           =2 #if (SDCC >= 300)
           =2 
           =2 #define interrupt __interrupt
           =2 #define _asm __asm
           =2 #define _endasm __endasm
           =2 #define bit __bit
           =2 #define code __code
           =2 #define at __at
           =2 
           =2 #endif
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   __xdata
           =2 # define SEG_DATA  __data
           =2 # define SEG_NEAR  __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =2 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =2 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =2 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =2 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =2 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =2 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =2 
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 27  

           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() _asm NOP _endasm
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Raisonance (must be placed before Keil C51)
           =2 // http://www.raisonance.com
           =2 
           =2 #elif defined __RC51__
           =2 
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 28  

           =2 //#error Raisonance C51 detected.
           =2 
           =2 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =2 # define SFR(name, addr)        sfr at addr                name
           =2 # define SFR16(name, addr)      sfr16 at addr              name
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =2 
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 29  

           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support -- NOP is opcode 0x00
           =2 #define NOP() asm { 0x00 }
           =2 
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // Keil C51
           =2 // http://www.keil.com
           =2 
           =2 #elif defined __C51__
           =2 
           =2 //#error Keil C51 detected.
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   xdata
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  data
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 # define SBIT(name, addr, bit)  sbit  name = addr^bit
           =2 # define SFR(name, addr)        sfr   name = addr
           =2 # define SFR16(name, addr)      sfr16 name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO(name, vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =2 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 30  

           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 // define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop_ (void);
           =2 #define NOP() _nop_()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Hi-Tech 8051
           =2 // http://www.htsoft.com
           =2 
           =2 #elif defined HI_TECH_C
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   far
           =2 # define SEG_DATA  data
           =2 # define SEG_NEAR  near
           =2 # define SEG_IDATA idata
           =2 # define SEG_XDATA xdata
           =2 # define SEG_PDATA pdata
           =2 # define SEG_CODE  code
           =2 # define SEG_BDATA bdata
           =2 
           =2 
           =2 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =2 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 31  

           =2 
           =2 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =2 # define INTERRUPT_PROTO(name, vector)
           =2 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: Hi-Tech does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 # define b0 0
           =2 # define b1 1
           =2 # define b2 2
           =2 # define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 #define NOP() asm(" nop ")
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Tasking / Altium
           =2 // http://www.altium.com/tasking
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 32  

           =2 
           =2 
           =2 #elif defined _CC51
           =2 
           =2 # define SEG_GENERIC
           =2 # define SEG_FAR   _xdat
           =2 # define SEG_DATA  _data
           =2 # define SEG_NEAR  _data
           =2 # define SEG_IDATA _idat
           =2 # define SEG_XDATA _xdat
           =2 # define SEG_PDATA _pdat
           =2 # define SEG_CODE  _rom
           =2 # define SEG_BDATA _bdat
           =2 
           =2 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =2 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =2 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =2 #if _CC51 > 71
           =2 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =2 #else
           =2 # define SFR16(name, addr)      /* not supported */
           =2 #endif
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =2 
           =2 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =2 // is also using the same register bank. If not, the compiler will generate an error.
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =2 
           =2 // used with UU16
           =2 # define LSB 1
           =2 # define MSB 0
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 3
           =2 //# define b1 2
           =2 //# define b2 1
           =2 //# define b3 0
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 33  

           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 // NOP () macro support
           =2 extern void _nop (void);
           =2 #define NOP() _nop()
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 
           =2 // IAR 8051
           =2 // http://www.iar.com
           =2 
           =2 #elif defined __ICC8051__
           =2 
           =2 #include <stdbool.h>
           =2 #include <intrinsics.h>
           =2 
           =2 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =2 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =2 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =2 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr) /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 # define SEG_GENERIC __generic
           =2 # define SEG_FAR  __xdata
           =2 # define SEG_DATA __data
           =2 # define SEG_NEAR __data
           =2 # define SEG_IDATA __idata
           =2 # define SEG_XDATA __xdata
           =2 # define SEG_PDATA __pdata
           =2 # define SEG_CODE  __code
           =2 # define SEG_BDATA __bdata
           =2 
           =2 #define bit bool
           =2 
           =2 # define _PPTOSTR_(x) #x
           =2 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =2 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =2 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =2 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =2 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 34  

           =2 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =2 
           =2 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =2 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =2 // Note: IAR does not support functions using different register banks. Register
           =2 //       banks can only be specified in interrupts. If a function is called from
           =2 //       inside an interrupt, it will use the same register bank as the interrupt.
           =2 
           =2 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =2 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =2 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =2 
           =2 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =2 
           =2 // used with UU16
           =2 # define LSB 0
           =2 # define MSB 1
           =2 
           =2 // used with UU32 (b0 is least-significant byte)
           =2 //# define b0 0
           =2 //# define b1 1
           =2 //# define b2 2
           =2 //# define b3 3
           =2 
           =2 typedef unsigned char U8;
           =2 typedef unsigned int U16;
           =2 typedef unsigned long U32;
           =2 
           =2 typedef signed char S8;
           =2 typedef signed int S16;
           =2 typedef signed long S32;
           =2 
           =2 typedef union UU16
           =2 {
           =2    U16 U16;
           =2    S16 S16;
           =2    U8 U8[2];
           =2    S8 S8[2];
           =2 } UU16;
           =2 
           =2 typedef union UU32
           =2 {
           =2    U32 U32;
           =2    S32 S32;
           =2    UU16 UU16[2];
           =2    U16 U16[2];
           =2    S16 S16[2];
           =2    U8 U8[4];
           =2    S8 S8[4];
           =2 } UU32;
           =2 
           =2 
           =2 #define NOP() __no_operation();
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Crossware
           =2 // http://www.crossware.com
           =2 
           =2 #elif defined _XC51_VER
           =2 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =2 # define SFR(name, addr)        _sfr     name = addr
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 35  

           =2 # define SFR16(name, addr)      _sfrword name = addr
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Wickenhäuser
           =2 // http://www.wickenhaeuser.de
           =2 
           =2 #elif defined __UC__
           =2 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =2 # define SFR(name, addr)        near unsigned char name @ addr
           =2 # define SFR16(name, addr)      /* not supported */
           =2 # define SFR16E(name, fulladdr) /* not supported */
           =2 # define SFR32(name, fulladdr)  /* not supported */
           =2 # define SFR32E(name, fulladdr) /* not supported */
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 // Default
           =2 // Unknown compiler
           =2 
           =2 #else
           =2 # warning unrecognized compiler
           =2 # define SBIT(name, addr, bit)  volatile bool           name
           =2 # define SFR(name, addr)        volatile unsigned char  name
           =2 # define SFRX(name, addr)       volatile unsigned char  name
           =2 # define SFR16(name, addr)      volatile unsigned short name
           =2 # define SFR16E(name, fulladdr) volatile unsigned short name
           =2 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =2 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =2 
           =2 #endif
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Header File PreProcessor Directive
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #endif                                 // #define COMPILER_DEFS_H
 689      =2  
 690      =2  //-----------------------------------------------------------------------------
 691      =2  // End Of File
 692      =2  //-----------------------------------------------------------------------------
  20      =1  //-----------------------------------------------------------------------------
  21      =1  // Open Header #define
  22      =1  //-----------------------------------------------------------------------------
  23      =1  
  24      =1  
  25      =1  
  26      =1  //-----------------------------------------------------------------------------
  27      =1  // Structures, Unions, Enumerations, and Type Definitions
  28      =1  //-----------------------------------------------------------------------------
  29      =1  #define DTCCODE_ADDRESS                                 (0x8800)
  30      =1  #define ONESPEC_ADDRESS                                 (0x8D00)
  31      =1  #define SYSINFO_ADDRESS                                 (0x9200)
  32      =1  #define DTC_CODE_SIZE                                   (0x6)
  33      =1  #define PAGE_SIZE                                               (0x100)
  34      =1  
  35      =1  typedef U16 FLADDR;
  36      =1  
  37      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 36  

  38      =1  // Global Constants
  39      =1  //-----------------------------------------------------------------------------
  40      =1  
  41      =1  #ifndef FLASH_PAGESIZE
  42      =1  #define FLASH_PAGESIZE (512)
  43      =1  #endif
  44      =1  
  45      =1  #ifndef FLASH_TEMP
  46      =1  #define FLASH_TEMP 0x7800L             // For 32K Flash devices
  47      =1  //#define FLASH_TEMP 0x3C00L           // For 16K Flash devices
  48      =1  #endif
  49      =1  
  50      =1  #ifndef FLASH_LAST
  51      =1  #define FLASH_LAST 0x7A00L             // For 32K Flash devices
  52      =1  //#define FLASH_LAST 0x3E00L           // For 16K Flash devices
  53      =1  #endif
  54      =1  
  55      =1  #define PAGE_SIZE               256U
*** WARNING C317 IN LINE 55 OF drv_mem.h: attempt to redefine macro 'PAGE_SIZE'
  56      =1  //-----------------------------------------------------------------------------
  57      =1  // Exported Function Prototypes
  58      =1  //-----------------------------------------------------------------------------
  59      =1  
  60      =1  // FLASH read/write/erase routines
  61      =1  
  62      =1  // FLASH update/copy routines
  63      =1  void FLASH_Update (FLADDR dest, U8 *src, U16 numbytes);
  64      =1  void FLASH_Copy (FLADDR dest, FLADDR src, U16 numbytes);
  65      =1  
  66      =1  // FLASH test routines
  67      =1  void F560_FLASH_Fill (FLADDR addr, U16 length, U8 fill);
  68      =1  //-----------------------------------------------------------------------------
  69      =1  // Close Header #define
  70      =1  //-----------------------------------------------------------------------------
  71      =1  void Mem_Flash_Clear(U16 ID);
  72      =1  void Flash_Clear(U16 ADDRESS);
  73      =1  U8 Mem_DTC_Flash_Read(U8 *DTC_Error);
  74      =1  void Mem_DTC_Flash_Write(U8 ID);
  75      =1  void Mem_DTC_Flash_Clear(U8 ID);
  76      =1  U8 Mem_DTC_Flash_Change_DTC_Error(void);
  77      =1  U8 FLASH_ByteWrite (FLADDR addr, U8 byte);
  78      =1  void FLASH_Write_Buf (FLADDR dest, U8 *src, U16 numbytes);
  79      =1  U8 FLASH_ByteRead (FLADDR addr);
  80      =1  U8 FLASH_PageErase (FLADDR addr);
  81      =1  void FLASH_Read_Buf (U8 *dest, FLADDR src, U16 numbytes,U8 BANK);
  82      =1  #endif    // _F560_FLASHPRIMITIVES_H_
  83      =1  
  84      =1  //-----------------------------------------------------------------------------
  85      =1  // End Of File
  86      =1  //-----------------------------------------------------------------------------
   6          #include "drv_timer.h"
   1      =1  #ifndef DRV_TIMER_H
   2      =1  #define DRV_TIMER_H
   3      =1  
   4      =1  /* ----- Global Define -------------------------------*/
   5      =1  
   6      =1  #define TID_FRAME_VALIDE                        0x01U
   7      =1  #define TID_FRAME_COUNT                         0x02U
   8      =1  #define TID_OVERLAY_GUIDELINE           0x03U
   9      =1  #define TID_SENSOR_IDLE_PERIOD          0x04U
  10      =1  #define TID_I2C_COMM_CHECK                      0x05U
  11      =1  #define TID_VCAN                                        0x06U
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 37  

  12      =1  #define TID_DTC_WRITE                   0x07U
  13      =1  #define TID_DIAG_ECU_RESET                      0x08U
  14      =1  #define TID_FIRME_UPDATE                        0x09U
  15      =1  #define TID_SENSOR_RESET                        0x0AU
  16      =1  #define TID_CHECKSTATUS_LOOP            0x0BU
  17      =1  #define TID_ADC_CHANGE_TIMER            0x0CU
  18      =1  #define TID_I2C_BUSY_CHECK                      0x0DU
  19      =1  #define TID_COUNT                                       0x0EU
  20      =1  
  21      =1  /*----------TIMER DELAY-------------*/
  22      =1  #define DT_FRAME_VALIDE                          80U
  23      =1  #define DT_FRAME_COUNT                          100U
  24      =1  #define DT_VCAN                                          10U
  25      =1  #define DT_OVERLAY_GUIDELINE         30U
  26      =1  #define DT_DTC_WRITE                    100U
  27      =1  #define DT_DIAG_ECU_RESET                   500U
  28      =1  #define DT_FIRME_UPDATE                          30U
  29      =1  #define DT_SENSOR_RESET                         500U
  30      =1  #define DT_SENSOR_IDLE_PERIOD           300U
  31      =1  #define DT_CHECKSTATUS_LOOP                      30U
  32      =1  #define DT_ADC_CHANGE_TIMER                  10U
  33      =1  #define DT_I2C_COMM_CHECK                    10U
  34      =1  #define DT_I2C_BUSY_CHECK                        50U
  35      =1  /*----------------------------------------------------*/
  36      =1  typedef struct {
  37      =1          U8      Set;
  38      =1          U32 Delay_Time;
  39      =1          U32 Cur_Time;
  40      =1          U32 End_Time;
  41      =1  }tMsg_Time_s;
  42      =1  
  43      =1  typedef struct {
  44      =1          U32 Tick_1ms;
  45      =1          U32     Limit;
  46      =1          U8      Over_Set;
  47      =1  }tMsg_Global_Tick;
  48      =1  
  49      =1  /* ----- Function ------------------------------------*/
  50      =1  void Timer0_Init(void);
  51      =1  void Timer1_Init(void);
  52      =1  #if defined(TIMER2)
  53      =1  void Timer2_Init(void);
  54      =1  #endif
  55      =1  void Timer3_Init(void);
  56      =1  void Timer4_Init(void);
  57      =1  void Timer5_Init(void);
  58      =1  void TIMER1__Init (void);
  59      =1  void Wait_ms (U16 ms);
  60      =1  void Global_Timer_Init(void);
  61      =1  void Delay_Time_Set(U8 ID, U16 Delay_Time);
  62      =1  U8   Delay_Time_Get(U8 ID);
  63      =1  void Delay_Time_Expire(U8 ID);
  64      =1  U16 Get_Time(void);
  65      =1  /*----------------------------------------------------*/
  66      =1  
  67      =1  /* ----- Extern Function -----------------------------*/
  68      =1  extern SEG_XDATA tMsg_Global_Tick g_Global_Tick_Msg;
  69      =1  extern SEG_XDATA tMsg_Time_s    ga_tCAN_Time_Msg[TID_COUNT];
  70      =1  /*----------------------------------------------------*/
  71      =1  
  72      =1  /* ----- Global Value --------------------------------*/
  73      =1  /*----------------------------------------------------*/
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 38  

  74      =1  
  75      =1  #endif
   7          #include "mgr_diag.h"
   1      =1  //#include "drv_i2c.h"
   2      =1  #ifndef MGR_DIAG_H
   3      =1  #define MGR_DIAG_H
   4      =1  /* ----- Global Define -------------------------------*/
   5      =1  //DTC INFO
   6      =1  #define DTC_MCU_WT_ERR                          0x00U
   7      =1  #define DTC_MCU_MC_ERR                          0x01U
   8      =1  #define DTC_SENSOR_FV_ERR                       0x02U
   9      =1  #define DTC_SENSOR_FC_ERR                       0x03U
  10      =1  #define DTC_SENSOR_ISPSTAT_ERR          0x04U
  11      =1  #define DTC_VIDEO_OUT_CUT_ERR           0x07U
  12      =1  #define DTC_VIDEO_OVER_VOL_ERR          0x08U
  13      =1  #define DTC_CODE_COUNT                          0x09U
  14      =1  
  15      =1  #define DTC_CODE_INTERNAL_ERROR         0x00U
  16      =1  #define DTC_CODE_SENSOR_ERROR           0x01U
  17      =1  #define DTC_CODE_OUTPUT_ERROR           0x02U
  18      =1  
  19      =1  
  20      =1  #define DTC_MCU_WD_ERROR                        Record_DTC_Error(DTC_MCU_WT_ERR)
  21      =1  #define DTC_MCU_WD_CLEAR                        Record_DTC_Clear(DTC_MCU_WT_ERR)
  22      =1  #define DTC_MCU_MC_ERROR                        Record_DTC_Error(DTC_MCU_MC_ERR)
  23      =1  #define DTC_MCU_MC_CLEAR                        Record_DTC_Clear(DTC_MCU_MC_ERR)
  24      =1  #define DTC_ISP_FV_ERROR                        Record_DTC_Error(DTC_SENSOR_FV_ERR)
  25      =1  #define DTC_ISP_FV_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FV_ERR)
  26      =1  #define DTC_ISP_FC_ERROR                        Record_DTC_Error(DTC_SENSOR_FC_ERR)
  27      =1  #define DTC_ISP_FC_CLEAR                        Record_DTC_Clear(DTC_SENSOR_FC_ERR)
  28      =1  #define DTC_ISP_IS_ERROR                        Record_DTC_Error(DTC_SENSOR_ISPSTAT_ERR)
  29      =1  #define DTC_ISP_IS_CLEAR                        Record_DTC_Clear(DTC_SENSOR_ISPSTAT_ERR)
  30      =1  #define DTC_VID_OC_ERROR                        Record_DTC_Error(DTC_VIDEO_OUT_CUT_ERR)
  31      =1  #define DTC_VID_OC_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OUT_CUT_ERR)
  32      =1  #define DTC_VID_VO_ERROR                        Record_DTC_Error(DTC_VIDEO_OVER_VOL_ERR)
  33      =1  #define DTC_VID_VO_CLEAR                        Record_DTC_Clear(DTC_VIDEO_OVER_VOL_ERR)
  34      =1          
  35      =1  
  36      =1  #define DTC_CURRENT_ERROR                       0x09U
  37      =1  #define DTC_CONFIRM_ERROR                       0x08U
  38      =1  #define DTC_CLEAR                                       0xFFU
  39      =1  
  40      =1  //SYSTEM INFO
  41      =1  #define SYS_HMC_SPEC                            0x02U
  42      =1  #define SYS_HMC_SPEC_L                          0x03U
  43      =1  
  44      =1  #define SYS_PART_NUMBER                         0x87U
  45      =1  #define SYS_PART_NUMBER_L                       0x00U
  46      =1  #define SYS_MANU_DATE                           0x8BU
  47      =1  #define SYS_MANU_DATE_L                         (U8)SYS_PART_NUMBER_L+0x0aU
  48      =1  #define SYS_HW_VERSION                          0x93U
  49      =1  #define SYS_HW_VERSION_L                        (U8)SYS_MANU_DATE_L + 0x08U
  50      =1  #define SYS_SW_VERSION                          0x95U
  51      =1  #define SYS_SW_VERSION_L                        (U8)SYS_HW_VERSION_L + 0x03U
  52      =1  #define SYS_CAN_VERSION                         0x00U
  53      =1  #define SYS_CAN_VERSION_L                       (U8)SYS_SW_VERSION_L + 0x03U
  54      =1  #define SYS_CODE_COUNT                          0x07U
  55      =1  #define SYS_CODE_SIZE                           0x25U
  56      =1  #define SYS_WRITE_CODE_SIZE                     0x27U
  57      =1  //ROUTINE CONTROL 
  58      =1  
  59      =1  #define RTN_CTRL_ERASE_MEMORY           0xFF00U
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 39  

  60      =1  #define RTN_CTRL_CHECK_PRG_DEPEND       0xFF01U
  61      =1  #define RTN_CTRL_SENSOR_RESET           0xF1F0U
  62      =1  #define RTN_CTRL_GUIDE_ONOFF            0xF1F1U
  63      =1  #define RTN_CTRL_WARNING_ONOFF          0xF1F2U
  64      =1  
  65      =1  #define RTN_CTRL_DEFAULT                        0x00U
  66      =1  #define RTN_CTRL_FIMR_UPDATE            0x01U //only RTN_CTRL_ERASE_MEMORY
  67      =1  #define RTN_CTRL_BINARY_UPDATE          0x02U //only RTN_CTRL_ERASE_MEMORY 
  68      =1  
  69      =1  #define HMC_SPEC_OPTIC_X_HIGH_PID                        4U
  70      =1  #define HMC_SPEC_OPTIC_X_LOW_PID                         5U
  71      =1  #define HMC_SPEC_OPTIC_Y_HIGH_PID                        6U
  72      =1  #define HMC_SPEC_OPTIC_Y_LOW_PID                         7U
  73      =1  #define HMC_SPEC_COUNTRY_CFG_PID                         8U
  74      =1  #define HMC_SPEC_TEMPERATURE_PID                         9U
  75      =1  #define HMC_SPEC_SAS_ANGLE_HIGH_PID                     10U
  76      =1  #define HMC_SPEC_SAS_ANGLE_LOW_PID                      11U
  77      =1  #define HMC_SPEC_DTC_CURRENT_HIGH_PID           12U
  78      =1  #define HMC_SPEC_DTC_CURRENT_LOW_PID            13U
  79      =1  #define HMC_SPEC_DTC_CONFIRM_HIGH_PID           14U
  80      =1  #define HMC_SPEC_DTC_CONFIRM_LOW_PID            15U
  81      =1  #define HMC_SPEC_TOTAL_COUNT                            16U
  82      =1  
  83      =1  #define OPTIC_X_HIGH_PID_1                       0x80U
  84      =1  #define OPTIC_X_LOW_PID_2                        0x40U
  85      =1  #define OPTIC_Y_HIGH_PID_3                       0x20U
  86      =1  #define OPTIC_Y_LOW_PID_4                        0x10U
  87      =1  #define COUNTRY_CFG_PID_5                        0x08U
  88      =1  #define TEMPERATURE_PID_6                        0x04U
  89      =1  #define SAS_ANGLE_HIGH_PID_7             0x02U
  90      =1  #define SAS_ANGLE_LOW_PID_8                      0x01U
  91      =1  #define DTC_CURRENT_HIGH_PID_9           0x80U
  92      =1  #define DTC_CURRENT_LOW_PID_A            0x40U
  93      =1  #define DTC_CONFIRM_HIGH_PID_B           0x20U
  94      =1  #define DTC_CONFIRM_LOW_PID_C            0x10U
  95      =1  
  96      =1  #define USE_CASE_1BYTE                           0xFFU  
  97      =1  #define USE_CASE_2BYTE                           0xF0U
  98      =1  #define USE_CASE_3BYTE                           0x00U
  99      =1  #define USE_CASE_4BYTE                           0x00U
 100      =1  
 101      =1  #define SAS_CLEAR                                        0x00U
 102      =1  #define SAS_ON                                           0x01U
 103      =1  #define SAS_PRE_ON                                       0x02U
 104      =1  
 105      =1  #define OPTIC_SETTING                           0x00U
 106      =1  #define ERASE_ONESPEC                           0x01U
 107      =1  #define ERASE_FLASH_ALL                         0x02U
 108      =1  
 109      =1  #define SIGNITURE_1_ADDR                        0xF000U
 110      =1  #define SIGNITURE_2_ADDR                        0xF001U
 111      =1  #define SIGNITURE_3_ADDR                        0xF002U
 112      =1  #define SIGNITURE_4_ADDR                        0xF003U
 113      =1  #define SIGNITURE_1_BYTE                        0xAAU
 114      =1  #define SIGNITURE_2_BYTE                        0xBBU
 115      =1  #define SIGNITURE_3_BYTE                        0xCCU
 116      =1  #define SIGNITURE_4_BYTE                        0xDDU
 117      =1  
 118      =1  #define FIRMWARE_SIZE_ADDR                      0x2E000U
 119      =1  #define TUNING_SIZE_ADDR                        0x2D000U
 120      =1  #define FIRMWARE                                        0x30000U
 121      =1  #define TUNING                                          0x00000U
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 40  

 122      =1  /*----------------------------------------------------*/
 123      =1  
 124      =1  /* ----- Function ------------------------------------*/
 125      =1  void Reset_Diag(void);
 126      =1  void Init_DiagTask(void);
 127      =1  void Operate_DiagTask();
 128      =1  void Diag_StandBy(U8 *pError);
 129      =1  void Diag_InterInit(U8 *pError);
 130      =1  void Diag_Idle(U8 *pError);
 131      =1  void Diag_Running(U8 *pError);
 132      =1  
 133      =1  void Diag_Ecu_Reset(void);
 134      =1  void Diag_Clear_DTC(void);
 135      =1  U8 Diag_Read_Dtc(U8 index);
 136      =1  void Diag_DTC_Error_WT(void);
 137      =1  
 138      =1  void Clear_DTC_Struct(void);
 139      =1  void Record_DTC_Error(U8 ID);
 140      =1  void Record_DTC_Clear(U8 ID);
 141      =1  void Diag_Read_Sys(U8 ID, U8 *Buf,U8 Length);
 142      =1  void Diag_Write_Sys(U8 ID, U8 *Buf,U8 Length);
 143      =1  void Diag_Check_Programming(void);
 144      =1  void Firmware_Update(void);
 145      =1  void Diag_Eeprom_Update(void);
 146      =1  void Diag_Request_Download(U8 *Buf,U8 Length);
 147      =1  void Diag_Write_Transfer_Data(U8 *Buf);
 148      =1  
 149      =1  /*----------------------------------------------------*/
 150      =1  
 151      =1  /* ----- Extern Function -----------------------------*/
 152      =1  //extern U16 i2c_master_read(U8 slave_addr, U16 addr);
 153      =1  /*----------------------------------------------------*/
 154      =1  
 155      =1  /* ----- Global Value --------------------------------*/
 156      =1  typedef struct {
 157      =1          U8 update_set;
 158      =1          U8 erase_set;
 159      =1          U8 write_count;
 160      =1          U32 total_write_cnt;    
 161      =1          U32 write_cnt;
 162      =1          U32 size;
 163      =1          U8 Write_Buf[256];
 164      =1          
 165      =1  } tMsg_Update;
 166      =1  
 167      =1  #endif
 168      =1  /*----------------------------------------------------*/
 169      =1  
 170      =1  
 171      =1  
 172      =1  
   8          #include "string.h"
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STRING.H
   3      =1  
   4      =1  String functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STRING_H__
  10      =1  #define __STRING_H__
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 41  

  11      =1  
  12      =1  #ifndef _SIZE_T
  13      =1   #define _SIZE_T
  14      =1   typedef unsigned int size_t;
  15      =1  #endif
  16      =1  
  17      =1  #ifndef NULL
  18      =1   #define NULL ((void *) 0L)
  19      =1  #endif
  20      =1  
  21      =1  #pragma SAVE
  22      =1  #pragma REGPARMS
  23      =1  extern char *strcat (char *s1, char *s2);
  24      =1  extern char *strncat (char *s1, char *s2, int n);
  25      =1  
  26      =1  extern char strcmp (char *s1, char *s2);
  27      =1  extern char strncmp (char *s1, char *s2, int n);
  28      =1  
  29      =1  extern char *strcpy (char *s1, char *s2);
  30      =1  extern char *strncpy (char *s1, char *s2, int n);
  31      =1  
  32      =1  extern int strlen (char *);
  33      =1  
  34      =1  extern char *strchr (const char *s, char c);
  35      =1  extern int strpos (const char *s, char c);
  36      =1  extern char *strrchr (const char *s, char c);
  37      =1  extern int strrpos (const char *s, char c);
  38      =1  
  39      =1  extern int strspn (char *s, char *set);
  40      =1  extern int strcspn (char *s, char *set);
  41      =1  extern char *strpbrk (char *s, char *set);
  42      =1  extern char *strrpbrk (char *s, char *set);
  43      =1  extern char *strstr  (char *s, char *sub);
  44      =1  extern char *strtok  (char *str, const char *set);
  45      =1  
  46      =1  extern char memcmp (void *s1, void *s2, int n);
  47      =1  extern void *memcpy (void *s1, void *s2, int n);
  48      =1  extern void *memchr (void *s, char val, int n);
  49      =1  extern void *memccpy (void *s1, void *s2, char val, int n);
  50      =1  extern void *memmove (void *s1, void *s2, int n);
  51      =1  extern void *memset  (void *s, char val, int n);
  52      =1  #pragma RESTORE
  53      =1  
  54      =1  #endif
   9          //-----------------------------------------------------------------------------
  10          // Function Prototypes
  11          //-----------------------------------------------------------------------------
  12          SEG_XDATA U8 Rv_Buf[256];
  13          
  14          U8  FLASH_ByteWrite (FLADDR addr, U8 byte);
  15          U8  FLASH_ByteRead  (FLADDR addr);
  16          U8  FLASH_PageErase (FLADDR addr);
  17          void FLASH_Write_Buf (FLADDR dest, U8 *src, U16 numbytes);
  18          //-----------------------------------------------------------------------------
  19          // F560_FLASH_ByteWrite
  20          //-----------------------------------------------------------------------------
  21          //
  22          // Return Value : None
  23          // Parameters   :
  24          //   1) FLADDR addr - address of the byte to write to
  25          //                    valid range is 0x0000 to 0x7BFF for 32K Flash devices
  26          //                    valid range is 0x0000 to 0x3FFF for 16K Flash devices
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 42  

  27          //   2) U8 byte - byte to write to Flash.
  28          //
  29          // This routine writes <byte> to the linear FLASH address <addr>.
  30          //
  31          // This routine conforms to the recommendations in the C8051F56x data sheet
  32          // 
  33          // If the MCU is operating from the internal voltage regulator, the VDD
  34          // monitor should be set threshold and enabled as a reset source only when
  35          // writing or erasing Flash. Otherwise, it should be set to the low threshold.
  36          //
  37          // If the MCU is operating from an external voltage regulator powering VDD
  38          // directly, the VDD monitor can be set to the high threshold permanently.
  39          //-----------------------------------------------------------------------------
  40          
  41          U8 FLASH_ByteWrite (FLADDR addr, U8 byte)
  42          {
  43   1      
  44   1      #ifndef __PST_PolySpace__
  45   1         bit EA_SAVE = EA;                   // Preserve EA
  46   1      #else
                 U8 EA_SAVE = EA;
              #endif                  // Preserve EA
  49   1         U8 xdata * data pwrite;             // FLASH write pointer
  50   1         U8 ret = 0x00U;
  51   1         U8 i;
  52   1      
  53   1         U8 SFRPAGE_save = SFRPAGE;
  54   1         SFRPAGE = ACTIVE_PAGE;
  55   1      
  56   1         EA = 0U;                             // Disable interrupts
  57   1      
  58   1         RSTSRC = 0x00U | 0x04U;                      // 1. Disable VDD monitor as a reset source
  59   1      
  60   1         VDM0CN = 0xA0U;                      // 2. Enable VDD monitor and high threshold
  61   1      
  62   1         for (i = 0U; i < 20U; i++) {}        // 3. Wait for VDD monitor to stabilize
  63   1      
  64   1         if ( (VDM0CN & 0x40U) == 0x00U)               // 4. If the VDD voltage is not high
  65   1         {
  66   2            ret = 0U;                        //    enough don't write to Flash
  67   2                VDM0CN = 0x80U;         
  68   2                for (i = 0U; i < 20U; i++) {}        // 3. Wait for VDD monitor to stabilize
  69   2                RSTSRC = 0x02U | 0x04U;
  70   2         }
  71   1         else
  72   1         {
  73   2                 ret = 1U;   
  74   2                 RSTSRC = 0x02U | 0x04U;                      // 5. Safe to enable VDD Monitor as a 
  75   2                                                     //    reset source
  76   2      
  77   2                 pwrite = (U8 xdata *) addr;
  78   2      
  79   2                                                     // 6. Enable Flash Writes
  80   2      
  81   2                 FLKEY  = 0xA5U;                      // Key Sequence 1
  82   2                 FLKEY  = 0xF1U;                      // Key Sequence 2
  83   2                 PSCTL |= 0x01U;                      // PSWE = 1 which enables writes
  84   2      
  85   2                 VDM0CN = 0xA0U;                      // 7. Enable VDD monitor and high threshold
  86   2      
  87   2                 RSTSRC = 0x02U | 0x04U;                      // 8. Enable VDD monitor as a reset source
  88   2      
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 43  

  89   2                 *pwrite = byte;                     // 9. Write the byte
  90   2      
  91   2                 RSTSRC = 0x00U | 0x04U;                      // 10. Disable the VDD monitor as reset 
  92   2                                                     //     source
  93   2                 VDM0CN = 0x80U;                      // 11. Change VDD Monitor to low threshold
  94   2              
  95   2                 for (i = 0U; i < 20U; i++) {}        // 3. Wait for VDD monitor to stabilize
  96   2              
  97   2                 RSTSRC = 0x02U | 0x04U;                      // 12. Re-enable the VDD monitor as a 
  98   2                                                     //     reset source
  99   2      
 100   2                 PSCTL &= ~0x01U;                     // PSWE = 0 which disable writes
 101   2      
 102   2                 EA = EA_SAVE;                       // Restore interrupts
 103   2      
 104   2                 SFRPAGE = SFRPAGE_save;
 105   2         }
 106   1         return ret;                           // Write completed successfully
 107   1      }
 108          
 109          //-----------------------------------------------------------------------------
 110          // F560_FLASH_ByteRead
 111          //-----------------------------------------------------------------------------
 112          //
 113          // Return Value :
 114          //      U8 - byte read from Flash
 115          // Parameters   :
 116          //   1) FLADDR addr - address of the byte to read to
 117          //                    valid range is 0x0000 to 0x7BFF for 32K Flash devices
 118          //                    valid range is 0x0000 to 0x3FFF for 16K Flash devices
 119          //
 120          // This routine reads a <byte> from the linear FLASH address <addr>.
 121          //-----------------------------------------------------------------------------
 122          
 123          U8 FLASH_ByteRead (FLADDR addr)
 124          {
 125   1      #ifndef __PST_PolySpace__
 126   1         bit EA_SAVE = EA;                   // Preserve EA
 127   1      #else
                 U8 EA_SAVE = EA;
              #endif                  // Preserve EA
 130   1         U8 code * data pread;               // FLASH read pointer
 131   1         U8 byte;
 132   1      
 133   1         EA = 0U;                             // Disable interrupts
 134   1      
 135   1         pread = (U8 code *) addr;
 136   1      
 137   1         byte = *pread;                      // Read the byte
 138   1      
 139   1         EA = EA_SAVE;                       // Restore interrupts
 140   1      
 141   1         return byte;
 142   1      }
 143          
 144          //-----------------------------------------------------------------------------
 145          // F560_FLASH_PageErase
 146          //-----------------------------------------------------------------------------
 147          //
 148          // Return Value : None
 149          // Parameters   :
 150          //   1) FLADDR addr - address of any byte in the page to erase
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 44  

 151          //                    valid range is 0x0000 to 0x79FF for 32K Flash devices
 152          //                    valid range is 0x0000 to 0x3DFF for 16K Flash devices
 153          //
 154          // This routine erases the FLASH page containing the linear FLASH address
 155          // <addr>.  Note that the page of Flash containing the Lock Byte cannot be
 156          // erased from application code.
 157          //
 158          //// This routine conforms to the recommendations in the C8051F56x data sheet
 159          //
 160          // If the MCU is operating from the internal voltage regulator, the VDD
 161          // monitor should be set threshold and enabled as a reset source only when
 162          // writing or erasing Flash. Otherwise, it should be set to the low threshold.
 163          //
 164          // If the MCU is operating from an external voltage regulator powering VDD
 165          // directly, the VDD monitor can be set to the high threshold permanently.
 166          //-----------------------------------------------------------------------------
 167          
 168          U8 FLASH_PageErase (FLADDR addr)
 169          {
 170   1      #ifndef __PST_PolySpace__
 171   1         bit EA_SAVE = EA;                   // Preserve EA
 172   1      #else
                 U8 EA_SAVE = EA;
              #endif                  // Preserve EA
 175   1         U8 xdata * data pwrite;             // FLASH write pointer
 176   1         U8 ret = 0x00U;
 177   1         U8 i;
 178   1      
 179   1         U8 SFRPAGE_save = SFRPAGE;
 180   1         SFRPAGE = ACTIVE_PAGE;
 181   1      
 182   1         EA = 0U;                             // Disable interrupts
 183   1      
 184   1         RSTSRC = 0x00U | 0x04U;                      // 1. Disable VDD monitor as a reset source
 185   1      
 186   1         VDM0CN = 0xA0U;                      // 2. Enable VDD monitor and high threshold
 187   1      
 188   1         for (i = 0U; i < 20U; i++) {}        // 3. Wait for VDD monitor to stabilize
 189   1      
 190   1         if ( (VDM0CN & 0x40U) == 0x00U )               // 4. If the VDD voltage is not high enough
 191   1         {
 192   2            ret = 0U;                        //    don't attempt to write to Flash
 193   2                VDM0CN = 0x80U;         
 194   2                for (i = 0U; i < 20U; i++) {}        // 3. Wait for VDD monitor to stabilize
 195   2                RSTSRC = 0x02U | 0x04U;
 196   2         }
 197   1         else
 198   1         {    
 199   2                ret = 1U;
 200   2         
 201   2                 RSTSRC = 0x02U | 0x04U;                      // 5. Safe to enable VDD Monitor as a reset 
 202   2                                                     //    source
 203   2      
 204   2                 pwrite = (U8 xdata *) addr;
 205   2                                                     // 6. Enable Flash Writes
 206   2      
 207   2                 FLKEY  = 0xA5U;                      // Key Sequence 1
 208   2                 FLKEY  = 0xF1U;                      // Key Sequence 2
 209   2                 PSCTL |= 0x03U;                      // PSWE = 1; PSEE = 1
 210   2      
 211   2                 VDM0CN = 0xA0U;                      // 7. Enable VDD monitor and high threshold
 212   2      
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 45  

 213   2                 RSTSRC = 0x02U | 0x04U;                      // 8. Enable VDD monitor as a reset source
 214   2      
 215   2                 *pwrite = 0U;                        // 9. Initiate page erase
 216   2      
 217   2                 RSTSRC = 0x00U | 0x04U;                      // 10. Disable the VDD monitor as a reset
 218   2                                                     //     source
 219   2                 VDM0CN = 0x80U;                      // 11. Change VDD Monitor to low threshold
 220   2                 
 221   2                 for (i = 0U; i < 20U; i++) {}        // 3. Wait for VDD monitor to stabilize
 222   2                 
 223   2                 RSTSRC = 0x02U | 0x04U;                      // 12. Re-enable the VDD monitor as a reset 
 224   2                                                     //     source
 225   2      
 226   2                 PSCTL &= ~0x03U;                     // PSWE = 0; PSEE = 0
 227   2      
 228   2                 EA = EA_SAVE;                       // Restore interrupts
 229   2      
 230   2                 SFRPAGE = SFRPAGE_save;
 231   2         }
 232   1         return ret;
 233   1      }
 234          
 235          void FLASH_Write_Buf (FLADDR dest, U8 *src, U32 numbytes)
 236          {
*** WARNING C235 IN LINE 236 OF drv_mem.c: parameter 3: different types
 237   1         FLADDR i;
 238   1         U8 j;
 239   1      
 240   1              static SEG_XDATA U32 index = 0x00000000U;
 241   1      
 242   1         for (i = dest; i < (dest+numbytes); i++) 
 243   1         {
 244   2                if ( i >= 0x8000 && i < 0xFFFF)
 245   2                {
 246   3                      PSBANK = 0x10;
 247   3              FLASH_ByteWrite (i, *src++);
 248   3                      PSBANK = 0x00;
 249   3                }
 250   2                else if ( i >= 0x10000)
 251   2                {
 252   3                      PSBANK = 0x20;
 253   3                      i -= 0x4000;
 254   3              FLASH_ByteWrite (i, *src++);
 255   3                      PSBANK = 0x00;
 256   3                }
 257   2                else
 258   2                {
 259   3                    FLASH_ByteWrite (i, *src++);
 260   3                }
 261   2         }
 262   1      }
*** WARNING C280 IN LINE 238 OF drv_mem.c: 'j': unreferenced local variable
*** WARNING C280 IN LINE 240 OF drv_mem.c: 'index': unreferenced local variable
 263          
 264          void Mem_Flash_Clear(U16 ID)
 265          {
 266   1              U8 F_ret;
 267   1              PSBANK = 0x20U;
 268   1              F_ret = FLASH_PageErase(ID);
 269   1              PSBANK = 0x00U;
 270   1      }
 271          
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 46  

 272          void FLASH_Read_Buf (U8 *dest, FLADDR src, U16 numbytes,U8 BANK)
 273          {
 274   1         FLADDR i;
 275   1         SEG_XDATA U8 index = 0x00U;
 276   1         U8 Save_Bank = PSBANK;
 277   1         PSBANK = BANK;
 278   1      
 279   1         for (i = 0; i < numbytes; i++) 
 280   1         {
 281   2            dest[index] = FLASH_ByteRead (src+i);
 282   2                index++;
 283   2         }
 284   1         PSBANK = Save_Bank;
 285   1      }
 286          
 287          //-----------------------------------------------------------------------------
 288          // End Of File
 289          //-----------------------------------------------------------------------------
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 47  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _FLASH_ByteWrite (BEGIN)
                                           ; SOURCE LINE # 41
0000 900000      R     MOV     DPTR,#addr
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
;---- Variable 'byte' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 42
                                           ; SOURCE LINE # 45
0008 A2AF              MOV     C,EA
000A 9200        R     MOV     EA_SAVE,C
                                           ; SOURCE LINE # 50
;---- Variable 'ret' assigned to Register 'R7' ----
000C E4                CLR     A
000D FF                MOV     R7,A
                                           ; SOURCE LINE # 53
;---- Variable 'SFRPAGE_save' assigned to Register 'R1' ----
000E A9A7              MOV     R1,SFRPAGE
                                           ; SOURCE LINE # 54
0010 F5A7              MOV     SFRPAGE,A
                                           ; SOURCE LINE # 56
0012 C2AF              CLR     EA
                                           ; SOURCE LINE # 58
0014 75EF04            MOV     RSTSRC,#04H
                                           ; SOURCE LINE # 60
0017 75FFA0            MOV     VDM0CN,#0A0H
                                           ; SOURCE LINE # 62
;---- Variable 'i' assigned to Register 'R6' ----
001A FE                MOV     R6,A
001B         ?C0001:
001B EE                MOV     A,R6
001C C3                CLR     C
001D 9414              SUBB    A,#014H
001F 5003              JNC     ?C0002
0021 0E                INC     R6
0022 80F7              SJMP    ?C0001
0024         ?C0002:
                                           ; SOURCE LINE # 64
0024 E5FF              MOV     A,VDM0CN
0026 5440              ANL     A,#040H
0028 7013              JNZ     ?C0004
                                           ; SOURCE LINE # 65
                                           ; SOURCE LINE # 66
002A FF                MOV     R7,A
                                           ; SOURCE LINE # 67
002B 75FF80            MOV     VDM0CN,#080H
                                           ; SOURCE LINE # 68
002E FE                MOV     R6,A
002F         ?C0005:
002F EE                MOV     A,R6
0030 C3                CLR     C
0031 9414              SUBB    A,#014H
0033 5003              JNC     ?C0006
0035 0E                INC     R6
0036 80F7              SJMP    ?C0005
0038         ?C0006:
                                           ; SOURCE LINE # 69
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 48  

0038 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 70
003B 8047              SJMP    ?C0008
003D         ?C0004:
                                           ; SOURCE LINE # 72
                                           ; SOURCE LINE # 73
003D 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 74
003F 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 77
0042 900000      R     MOV     DPTR,#addr
0045 E0                MOVX    A,@DPTR
0046 FA                MOV     R2,A
0047 A3                INC     DPTR
0048 E0                MOVX    A,@DPTR
0049 8A00        R     MOV     pwrite,R2
004B F500        R     MOV     pwrite+01H,A
                                           ; SOURCE LINE # 81
004D 75B7A5            MOV     FLKEY,#0A5H
                                           ; SOURCE LINE # 82
0050 75B7F1            MOV     FLKEY,#0F1H
                                           ; SOURCE LINE # 83
0053 438F01            ORL     PSCTL,#01H
                                           ; SOURCE LINE # 85
0056 75FFA0            MOV     VDM0CN,#0A0H
                                           ; SOURCE LINE # 87
0059 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 89
005C 850082      R     MOV     DPL,pwrite+01H
005F 850083      R     MOV     DPH,pwrite
0062 ED                MOV     A,R5
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 91
0064 75EF04            MOV     RSTSRC,#04H
                                           ; SOURCE LINE # 93
0067 75FF80            MOV     VDM0CN,#080H
                                           ; SOURCE LINE # 95
006A E4                CLR     A
006B FE                MOV     R6,A
006C         ?C0009:
006C EE                MOV     A,R6
006D C3                CLR     C
006E 9414              SUBB    A,#014H
0070 5003              JNC     ?C0010
0072 0E                INC     R6
0073 80F7              SJMP    ?C0009
0075         ?C0010:
                                           ; SOURCE LINE # 97
0075 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 100
0078 538FFE            ANL     PSCTL,#0FEH
                                           ; SOURCE LINE # 102
007B A200        R     MOV     C,EA_SAVE
007D 92AF              MOV     EA,C
                                           ; SOURCE LINE # 104
007F CE                XCH     A,R6
0080 E9                MOV     A,R1
0081 CE                XCH     A,R6
0082 8EA7              MOV     SFRPAGE,R6
                                           ; SOURCE LINE # 105
0084         ?C0008:
                                           ; SOURCE LINE # 106
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 49  

                                           ; SOURCE LINE # 107
0084         ?C0012:
0084 22                RET     
             ; FUNCTION _FLASH_ByteWrite (END)

             ; FUNCTION _FLASH_ByteRead (BEGIN)
                                           ; SOURCE LINE # 123
;---- Variable 'addr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 126
0000 A2AF              MOV     C,EA
0002 9200        R     MOV     EA_SAVE,C
                                           ; SOURCE LINE # 133
0004 C2AF              CLR     EA
                                           ; SOURCE LINE # 135
0006 8E00        R     MOV     pread,R6
0008 8F00        R     MOV     pread+01H,R7
                                           ; SOURCE LINE # 137
000A 8F82              MOV     DPL,R7
000C 8E83              MOV     DPH,R6
000E E4                CLR     A
000F 93                MOVC    A,@A+DPTR
0010 FF                MOV     R7,A
;---- Variable 'byte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 139
0011 A200        R     MOV     C,EA_SAVE
0013 92AF              MOV     EA,C
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 142
0015         ?C0013:
0015 22                RET     
             ; FUNCTION _FLASH_ByteRead (END)

             ; FUNCTION _FLASH_PageErase (BEGIN)
                                           ; SOURCE LINE # 168
;---- Variable 'addr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 169
                                           ; SOURCE LINE # 171
0000 A2AF              MOV     C,EA
0002 9200        R     MOV     EA_SAVE,C
                                           ; SOURCE LINE # 176
;---- Variable 'ret' assigned to Register 'R5' ----
0004 E4                CLR     A
0005 FD                MOV     R5,A
                                           ; SOURCE LINE # 179
;---- Variable 'SFRPAGE_save' assigned to Register 'R1' ----
0006 A9A7              MOV     R1,SFRPAGE
                                           ; SOURCE LINE # 180
0008 F5A7              MOV     SFRPAGE,A
                                           ; SOURCE LINE # 182
000A C2AF              CLR     EA
                                           ; SOURCE LINE # 184
000C 75EF04            MOV     RSTSRC,#04H
                                           ; SOURCE LINE # 186
000F 75FFA0            MOV     VDM0CN,#0A0H
                                           ; SOURCE LINE # 188
;---- Variable 'i' assigned to Register 'R4' ----
0012 FC                MOV     R4,A
0013         ?C0014:
0013 EC                MOV     A,R4
0014 C3                CLR     C
0015 9414              SUBB    A,#014H
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 50  

0017 5003              JNC     ?C0015
0019 0C                INC     R4
001A 80F7              SJMP    ?C0014
001C         ?C0015:
                                           ; SOURCE LINE # 190
001C E5FF              MOV     A,VDM0CN
001E 5440              ANL     A,#040H
0020 7013              JNZ     ?C0017
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 192
0022 FD                MOV     R5,A
                                           ; SOURCE LINE # 193
0023 75FF80            MOV     VDM0CN,#080H
                                           ; SOURCE LINE # 194
0026 FC                MOV     R4,A
0027         ?C0018:
0027 EC                MOV     A,R4
0028 C3                CLR     C
0029 9414              SUBB    A,#014H
002B 5003              JNC     ?C0019
002D 0C                INC     R4
002E 80F7              SJMP    ?C0018
0030         ?C0019:
                                           ; SOURCE LINE # 195
0030 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 196
0033 803F              SJMP    ?C0021
0035         ?C0017:
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 199
0035 7D01              MOV     R5,#01H
                                           ; SOURCE LINE # 201
0037 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 204
003A 8E00        R     MOV     pwrite,R6
003C 8F00        R     MOV     pwrite+01H,R7
                                           ; SOURCE LINE # 207
003E 75B7A5            MOV     FLKEY,#0A5H
                                           ; SOURCE LINE # 208
0041 75B7F1            MOV     FLKEY,#0F1H
                                           ; SOURCE LINE # 209
0044 438F03            ORL     PSCTL,#03H
                                           ; SOURCE LINE # 211
0047 75FFA0            MOV     VDM0CN,#0A0H
                                           ; SOURCE LINE # 213
004A 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 215
004D 850082      R     MOV     DPL,pwrite+01H
0050 850083      R     MOV     DPH,pwrite
0053 E4                CLR     A
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 217
0055 75EF04            MOV     RSTSRC,#04H
                                           ; SOURCE LINE # 219
0058 75FF80            MOV     VDM0CN,#080H
                                           ; SOURCE LINE # 221
005B FC                MOV     R4,A
005C         ?C0022:
005C EC                MOV     A,R4
005D C3                CLR     C
005E 9414              SUBB    A,#014H
0060 5003              JNC     ?C0023
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 51  

0062 0C                INC     R4
0063 80F7              SJMP    ?C0022
0065         ?C0023:
                                           ; SOURCE LINE # 223
0065 75EF06            MOV     RSTSRC,#06H
                                           ; SOURCE LINE # 226
0068 538FFC            ANL     PSCTL,#0FCH
                                           ; SOURCE LINE # 228
006B A200        R     MOV     C,EA_SAVE
006D 92AF              MOV     EA,C
                                           ; SOURCE LINE # 230
006F CF                XCH     A,R7
0070 E9                MOV     A,R1
0071 CF                XCH     A,R7
0072 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 231
0074         ?C0021:
                                           ; SOURCE LINE # 232
0074 CF                XCH     A,R7
0075 ED                MOV     A,R5
0076 CF                XCH     A,R7
                                           ; SOURCE LINE # 233
0077         ?C0025:
0077 22                RET     
             ; FUNCTION _FLASH_PageErase (END)

             ; FUNCTION _FLASH_Write_Buf (BEGIN)
                                           ; SOURCE LINE # 235
0000 900000      R     MOV     DPTR,#src
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
000B 900000      R     MOV     DPTR,#dest
000E EE                MOV     A,R6
000F F0                MOVX    @DPTR,A
0010 A3                INC     DPTR
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 242
0013 900000      R     MOV     DPTR,#i
0016 EE                MOV     A,R6
0017 F0                MOVX    @DPTR,A
0018 A3                INC     DPTR
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
001B         ?C0026:
001B 900000      R     MOV     DPTR,#dest
001E E0                MOVX    A,@DPTR
001F FE                MOV     R6,A
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 E4                CLR     A
0024 FC                MOV     R4,A
0025 FD                MOV     R5,A
0026 900000      R     MOV     DPTR,#numbytes
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 52  

0029 E0                MOVX    A,@DPTR
002A F8                MOV     R0,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D F9                MOV     R1,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FA                MOV     R2,A
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 2F                ADD     A,R7
0034 FB                MOV     R3,A
0035 EA                MOV     A,R2
0036 3E                ADDC    A,R6
0037 FA                MOV     R2,A
0038 ED                MOV     A,R5
0039 39                ADDC    A,R1
003A F9                MOV     R1,A
003B EC                MOV     A,R4
003C 38                ADDC    A,R0
003D F8                MOV     R0,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FE                MOV     R6,A
0041 A3                INC     DPTR
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 E4                CLR     A
0045 D3                SETB    C
0046 120000      E     LCALL   ?C?ULCMP
0049 5003              JNC     $ + 5H
004B 020000      R     LJMP    ?C0033
                                           ; SOURCE LINE # 243
                                           ; SOURCE LINE # 244
004E 900000      R     MOV     DPTR,#i
0051 E0                MOVX    A,@DPTR
0052 FE                MOV     R6,A
0053 A3                INC     DPTR
0054 E0                MOVX    A,@DPTR
0055 FF                MOV     R7,A
0056 EE                MOV     A,R6
0057 9480              SUBB    A,#080H
0059 4027              JC      ?C0029
005B EF                MOV     A,R7
005C 94FF              SUBB    A,#0FFH
005E EE                MOV     A,R6
005F 94FF              SUBB    A,#0FFH
0061 501F              JNC     ?C0029
                                           ; SOURCE LINE # 245
                                           ; SOURCE LINE # 246
0063 75F510            MOV     PSBANK,#010H
                                           ; SOURCE LINE # 247
0066 900000      R     MOV     DPTR,#src
0069 E0                MOVX    A,@DPTR
006A FB                MOV     R3,A
006B A3                INC     DPTR
006C E4                CLR     A
006D 75F001            MOV     B,#01H
0070 120000      E     LCALL   ?C?ILDIX
0073 A9F0              MOV     R1,B
0075 FA                MOV     R2,A
0076 120000      E     LCALL   ?C?CLDPTR
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 53  

0079 FD                MOV     R5,A
007A 120000      R     LCALL   _FLASH_ByteWrite
                                           ; SOURCE LINE # 248
007D E4                CLR     A
007E F5F5              MOV     PSBANK,A
                                           ; SOURCE LINE # 249
0080 8067              SJMP    ?C0028
0082         ?C0029:
                                           ; SOURCE LINE # 250
0082 900000      R     MOV     DPTR,#i
0085 E0                MOVX    A,@DPTR
0086 FE                MOV     R6,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A E4                CLR     A
008B FC                MOV     R4,A
008C FD                MOV     R5,A
008D FB                MOV     R3,A
008E FA                MOV     R2,A
008F 7901              MOV     R1,#01H
0091 F8                MOV     R0,A
0092 D3                SETB    C
0093 120000      E     LCALL   ?C?SLCMP
0096 5032              JNC     ?C0031
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 252
0098 75F520            MOV     PSBANK,#020H
                                           ; SOURCE LINE # 253
009B 900000      R     MOV     DPTR,#i+01H
009E E0                MOVX    A,@DPTR
009F 2400              ADD     A,#00H
00A1 F0                MOVX    @DPTR,A
00A2 900000      R     MOV     DPTR,#i
00A5 E0                MOVX    A,@DPTR
00A6 34C0              ADDC    A,#0C0H
00A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 254
00A9 E0                MOVX    A,@DPTR
00AA FE                MOV     R6,A
00AB A3                INC     DPTR
00AC E0                MOVX    A,@DPTR
00AD FF                MOV     R7,A
00AE 900000      R     MOV     DPTR,#src
00B1 E0                MOVX    A,@DPTR
00B2 FB                MOV     R3,A
00B3 A3                INC     DPTR
00B4 E4                CLR     A
00B5 75F001            MOV     B,#01H
00B8 120000      E     LCALL   ?C?ILDIX
00BB A9F0              MOV     R1,B
00BD FA                MOV     R2,A
00BE 120000      E     LCALL   ?C?CLDPTR
00C1 FD                MOV     R5,A
00C2 120000      R     LCALL   _FLASH_ByteWrite
                                           ; SOURCE LINE # 255
00C5 E4                CLR     A
00C6 F5F5              MOV     PSBANK,A
                                           ; SOURCE LINE # 256
00C8 801F              SJMP    ?C0028
00CA         ?C0031:
                                           ; SOURCE LINE # 258
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 54  

                                           ; SOURCE LINE # 259
00CA 900000      R     MOV     DPTR,#i
00CD E0                MOVX    A,@DPTR
00CE FE                MOV     R6,A
00CF A3                INC     DPTR
00D0 E0                MOVX    A,@DPTR
00D1 FF                MOV     R7,A
00D2 900000      R     MOV     DPTR,#src
00D5 E0                MOVX    A,@DPTR
00D6 FB                MOV     R3,A
00D7 A3                INC     DPTR
00D8 E4                CLR     A
00D9 75F001            MOV     B,#01H
00DC 120000      E     LCALL   ?C?ILDIX
00DF A9F0              MOV     R1,B
00E1 FA                MOV     R2,A
00E2 120000      E     LCALL   ?C?CLDPTR
00E5 FD                MOV     R5,A
00E6 120000      R     LCALL   _FLASH_ByteWrite
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 261
00E9         ?C0028:
00E9 900000      R     MOV     DPTR,#i+01H
00EC E0                MOVX    A,@DPTR
00ED 04                INC     A
00EE F0                MOVX    @DPTR,A
00EF 7006              JNZ     ?C0039
00F1 900000      R     MOV     DPTR,#i
00F4 E0                MOVX    A,@DPTR
00F5 04                INC     A
00F6 F0                MOVX    @DPTR,A
00F7         ?C0039:
00F7 020000      R     LJMP    ?C0026
                                           ; SOURCE LINE # 262
00FA         ?C0033:
00FA 22                RET     
             ; FUNCTION _FLASH_Write_Buf (END)

             ; FUNCTION _Mem_Flash_Clear (BEGIN)
                                           ; SOURCE LINE # 264
;---- Variable 'ID' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 267
0000 75F520            MOV     PSBANK,#020H
                                           ; SOURCE LINE # 268
0003 120000      R     LCALL   _FLASH_PageErase
0006 900000      R     MOV     DPTR,#F_ret
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 269
000B E4                CLR     A
000C F5F5              MOV     PSBANK,A
                                           ; SOURCE LINE # 270
000E 22                RET     
             ; FUNCTION _Mem_Flash_Clear (END)

             ; FUNCTION _FLASH_Read_Buf (BEGIN)
                                           ; SOURCE LINE # 272
0000 900000      R     MOV     DPTR,#dest
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 55  

0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C EC                MOV     A,R4
000D F0                MOVX    @DPTR,A
000E A3                INC     DPTR
000F ED                MOV     A,R5
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 275
0011 E4                CLR     A
0012 900000      R     MOV     DPTR,#index
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 276
0016 A3                INC     DPTR
0017 E5F5              MOV     A,PSBANK
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
001A 900000      R     MOV     DPTR,#BANK
001D E0                MOVX    A,@DPTR
001E F5F5              MOV     PSBANK,A
                                           ; SOURCE LINE # 279
0020 E4                CLR     A
0021 A3                INC     DPTR
0022 F0                MOVX    @DPTR,A
0023 A3                INC     DPTR
0024 F0                MOVX    @DPTR,A
0025         ?C0035:
0025 900000      R     MOV     DPTR,#numbytes
0028 E0                MOVX    A,@DPTR
0029 FE                MOV     R6,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D 900000      R     MOV     DPTR,#i
0030 E0                MOVX    A,@DPTR
0031 FC                MOV     R4,A
0032 A3                INC     DPTR
0033 E0                MOVX    A,@DPTR
0034 FD                MOV     R5,A
0035 C3                CLR     C
0036 9F                SUBB    A,R7
0037 EC                MOV     A,R4
0038 9E                SUBB    A,R6
0039 503D              JNC     ?C0036
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 281
003B 900000      R     MOV     DPTR,#src+01H
003E E0                MOVX    A,@DPTR
003F 2D                ADD     A,R5
0040 FF                MOV     R7,A
0041 900000      R     MOV     DPTR,#src
0044 E0                MOVX    A,@DPTR
0045 3C                ADDC    A,R4
0046 FE                MOV     R6,A
0047 120000      R     LCALL   _FLASH_ByteRead
004A 900000      R     MOV     DPTR,#dest
004D E0                MOVX    A,@DPTR
004E FB                MOV     R3,A
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 56  

004F A3                INC     DPTR
0050 E0                MOVX    A,@DPTR
0051 FA                MOV     R2,A
0052 A3                INC     DPTR
0053 E0                MOVX    A,@DPTR
0054 F9                MOV     R1,A
0055 900000      R     MOV     DPTR,#index
0058 E0                MOVX    A,@DPTR
0059 F582              MOV     DPL,A
005B 758300            MOV     DPH,#00H
005E EF                MOV     A,R7
005F 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 282
0062 900000      R     MOV     DPTR,#index
0065 E0                MOVX    A,@DPTR
0066 04                INC     A
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 283
0068 900000      R     MOV     DPTR,#i+01H
006B E0                MOVX    A,@DPTR
006C 04                INC     A
006D F0                MOVX    @DPTR,A
006E 7006              JNZ     ?C0040
0070 900000      R     MOV     DPTR,#i
0073 E0                MOVX    A,@DPTR
0074 04                INC     A
0075 F0                MOVX    @DPTR,A
0076         ?C0040:
0076 80AD              SJMP    ?C0035
0078         ?C0036:
                                           ; SOURCE LINE # 284
0078 900000      R     MOV     DPTR,#Save_Bank
007B E0                MOVX    A,@DPTR
007C F5F5              MOV     PSBANK,A
                                           ; SOURCE LINE # 285
007E 22                RET     
             ; FUNCTION _FLASH_Read_Buf (END)

C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 57  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
PSCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
FLKEY. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
PSBANK . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
VDM0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
FLADDR . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
_Mem_Flash_Clear . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ID . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  F_ret. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
_FLASH_ByteWrite . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  EA_SAVE. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  pwrite . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  2
  ret. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  SFRPAGE_save . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0001H  1
_FLASH_Write_Buf . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dest . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
  src. . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0002H  3
  numbytes . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0005H  4
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0009H  2
  j. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000BH  1
C51 COMPILER V9.51   DRV_MEM                                                               10/27/2023 14:29:11 PAGE 58  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  index. . . . . . . . . . . . . . . .  STATIC   XDATA  U_LONG   0000H  4
_FLASH_ByteRead. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  EA_SAVE. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  pread. . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  2
  byte . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_FLASH_PageErase . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  EA_SAVE. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  pwrite . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  2
  ret. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
  SFRPAGE_save . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0001H  1
_FLASH_Read_Buf. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dest . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  src. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0003H  2
  numbytes . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0005H  2
  BANK . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0008H  2
  index. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000AH  1
  Save_Bank. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000BH  1
tMsg_Time_s. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  13
  Set. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Delay_Time . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0001H  4
  Cur_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0005H  4
  End_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0009H  4
tMsg_Global_Tick . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Tick_1ms . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  Limit. . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
  Over_Set . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
tMsg_Update. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  271
  update_set . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  erase_set. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  write_count. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  total_write_cnt. . . . . . . . . . .  MEMBER   -----  U_LONG   0003H  4
  write_cnt. . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0007H  4
  size . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   000BH  4
  Write_Buf. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    000FH  256
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
Rv_Buf . . . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0004H  256


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    668    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    260      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
