C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DRV_SPI
OBJECT MODULE PLACED IN drv_spi.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe drv_spi.c DB OE BR INTVECTOR(0X4000) LARGE NOAREGS DEBUG OBJECTEXTEND SB
                    - DF(CLK_FREQUENCY=24,C_DERIVATIVE_C8051F5x) OR CD LC LARGE OT(6,SPEED) INCDIR(c:\SiLabs\MCU\Inc;D:\micom_diag\mcnex_diag
                    -nostic_bit\CANGEN_MCNEX;D:\micom_diag\mcnex_diagnostic_bit\CanBSW;c:\SiLabs\MCU_2\Inc)

line level    source

   1          /*_____ I N C L U D E __________________________________________*/
   2          #include "compiler_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // compiler_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Portions of this file are copyright Maarten Brock
   5      =1  // http://sdcc.sourceforge.net
   6      =1  // Portions of this file are copyright 2010, Silicon Laboratories, Inc.
   7      =1  // http://www.silabs.com
   8      =1  //
   9      =1  // GNU LGPL boilerplate:
  10      =1  /** This library is free software; you can redistribute it and/or
  11      =1    * modify it under the terms of the GNU Lesser General Public
  12      =1    * License as published by the Free Software Foundation; either
  13      =1    * version 2.1 of the License, or (at your option) any later version.
  14      =1    *
  15      =1    * This library is distributed in the hope that it will be useful,
  16      =1    * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17      =1    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  18      =1    * Lesser General Public License for more details.
  19      =1    *
  20      =1    * You should have received a copy of the GNU Lesser General Public
  21      =1    * License along with this library; if not, write to the Free Software
  22      =1    * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  23      =1    *
  24      =1    * In other words, you are welcome to use, share and improve this program.
  25      =1    * You are forbidden to forbid anyone else to use, share and improve
  26      =1    * what you give them. Help stamp out software-hoarding!
  27      =1  **/
  28      =1  // Program Description:
  29      =1  //
  30      =1  // **Important Note**: This header file should be included before including
  31      =1  // a device-specific header file such as C8051F300_defs.h.
  32      =1  //
  33      =1  // Macro definitions to accomodate 8051 compiler differences in specifying
  34      =1  // special function registers and other 8051-specific features such as NOP
  35      =1  // generation, and locating variables in memory-specific segments.  The
  36      =1  // compilers are identified by their unique predefined macros. See also:
  37      =1  // http://predef.sourceforge.net/precomp.html
  38      =1  //
  39      =1  // SBIT and SFR define special bit and special function registers at the given
  40      =1  // address. SFR16 and SFR32 define sfr combinations at adjacent addresses in
  41      =1  // little-endian format. SFR16E and SFR32E define sfr combinations without
  42      =1  // prerequisite byte order or adjacency. None of these multi-byte sfr
  43      =1  // combinations will guarantee the order in which they are accessed when read
  44      =1  // or written.
  45      =1  //
  46      =1  // SFR16X and SFR32X for 16 bit and 32 bit xdata registers are not defined
  47      =1  // to avoid portability issues because of compiler endianness.
  48      =1  //
  49      =1  // Example:
  50      =1  // // my_mcu.c: main 'c' file for my mcu
  51      =1  // #include <compiler_defs.h>  // this file
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 2   

  52      =1  // #include <C8051xxxx_defs.h> // SFR definitions for specific MCU target
  53      =1  //
  54      =1  // SBIT  (P0_1, 0x80, 1);      // Port 0 pin 1
  55      =1  // SFR   (P0, 0x80);           // Port 0
  56      =1  // SFRX  (CPUCS, 0xE600);      // Cypress FX2 Control and Status register in
  57      =1  //                             // xdata memory at 0xE600
  58      =1  // SFR16 (TMR2, 0xCC);         // Timer 2, lsb at 0xCC, msb at 0xCD
  59      =1  // SFR16E(TMR0, 0x8C8A);       // Timer 0, lsb at 0x8A, msb at 0x8C
  60      =1  // SFR32 (MAC0ACC, 0x93);      // SiLabs C8051F120 32 bits MAC0 Accumulator,
  61      =1  //                             // lsb at 0x93, msb at 0x96
  62      =1  // SFR32E(SUMR, 0xE5E4E3E2);   // TI MSC1210 SUMR 32 bits Summation register,
  63      =1  //                             // lsb at 0xE2, msb at 0xE5
  64      =1  //
  65      =1  // Target:         C8051xxxx
  66      =1  // Tool chain:     Generic
  67      =1  // Command Line:   None
  68      =1  // 
  69      =1  // Release 2.6 - 14 DEC 2012 (GO)
  70      =1  //        -Added define for deprecated SDCC keyword 'at'
  71      =1  // Release 2.5 - 12 SEP 2012 (TP)
  72      =1  //    -Added defines for deprecated SDCC keywords bit and code
  73      =1  // Release 2.4 - 27 AUG 2012 (TP)
  74      =1  //    -Added defines for deprecated SDCC keywords interrupt, _asm, and _endasm
  75      =1  // Release 2.3 - 27 MAY 2010 (DM)
  76      =1  //    -Removed 'LOCATED_VARIABLE' pragma from Keil because it is not supported
  77      =1  // Release 2.2 - 06 APR 2010 (ES)
  78      =1  //    -Removed 'PATHINCLUDE' pragma from Raisonance section
  79      =1  // Release 2.1 - 16 JUL 2009 (ES)
  80      =1  //    -Added SEGMENT_POINTER macro definitions for SDCC, Keil, and Raisonance
  81      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for Raisonance
  82      =1  // Release 2.0 - 19 MAY 2009 (ES)
  83      =1  //    -Added LOCATED_VARIABLE_NO_INIT macro definitions for SDCC and Keil
  84      =1  // Release 1.9 - 23 OCT 2008 (ES)
  85      =1  //    -Updated Hi-Tech INTERRUPT and INTERRUPT_USING macro definitions
  86      =1  //    -Added SFR16 macro defintion for Hi-Tech
  87      =1  // Release 1.8 - 31 JUL 2008 (ES)
  88      =1  //    -Added INTERRUPT_USING and FUNCTION_USING macro's
  89      =1  //    -Added macro's for IAR
  90      =1  //    -Corrected Union definitions for Hi-Tech and added SFR16 macro defintion
  91      =1  // Release 1.7 - 11 SEP 2007 (BW)
  92      =1  //    -Added support for Raisonance EVAL 03.03.42 and Tasking Eval 7.2r1
  93      =1  // Release 1.6 - 27 AUG 2007 (BW)
  94      =1  //    -Updated copyright notice per agreement with Maartin Brock
  95      =1  //    -Added SDCC 2.7.0 "compiler.h" bug fixes
  96      =1  //    -Added memory segment defines (SEG_XDATA, for example)
  97      =1  // Release 1.5 - 24 AUG 2007 (BW)
  98      =1  //    -Added support for NOP () macro
  99      =1  //    -Added support for Hi-Tech ver 9.01
 100      =1  // Release 1.4 - 07 AUG 2007 (PKC)
 101      =1  //    -Removed FID and fixed formatting.
 102      =1  // Release 1.3 - 30 SEP 2007 (TP)
 103      =1  //    -Added INTERRUPT_PROTO_USING to properly support ISR context switching
 104      =1  //     under SDCC.
 105      =1  // Release 1.2 - (BW)
 106      =1  //    -Added support for U8,U16,U32,S8,S16,S32,UU16,UU32 data types
 107      =1  // Release 1.1 - (BW)
 108      =1  //    -Added support for INTERRUPT, INTERRUPT_USING, INTERRUPT_PROTO,
 109      =1  //     SEGMENT_VARIABLE, VARIABLE_SEGMENT_POINTER,
 110      =1  //     SEGMENT_VARIABLE_SEGMENT_POINTER, and LOCATED_VARIABLE
 111      =1  // Release 1.0 - 29 SEP 2006 (PKC)
 112      =1  //    -Initial revision
 113      =1  
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 3   

 114      =1  //-----------------------------------------------------------------------------
 115      =1  // Header File Preprocessor Directive
 116      =1  //-----------------------------------------------------------------------------
 117      =1  
 118      =1  #ifndef COMPILER_DEFS_H
 119      =1  #define COMPILER_DEFS_H
 120      =1  
 121      =1  //-----------------------------------------------------------------------------
 122      =1  // Macro definitions
 123      =1  //-----------------------------------------------------------------------------
 124      =1  
 125      =1  // SDCC - Small Device C Compiler
 126      =1  // http://sdcc.sourceforge.net
 127      =1  
 128      =1  #if defined SDCC
           =1 
           =1 #if (SDCC >= 300)
           =1 
           =1 #define interrupt __interrupt
           =1 #define _asm __asm
           =1 #define _endasm __endasm
           =1 #define bit __bit
           =1 #define code __code
           =1 #define at __at
           =1 
           =1 #endif
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   __xdata
           =1 # define SEG_DATA  __data
           =1 # define SEG_NEAR  __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 # define SBIT(name, addr, bit)  __sbit  __at(addr+bit)                  name
           =1 # define SFR(name, addr)        __sfr   __at(addr)                      name
           =1 # define SFRX(name, addr)       xdata volatile unsigned char __at(addr) name
           =1 # define SFR16(name, addr)      __sfr16 __at(((addr+1U)<<8) | addr)     name
           =1 # define SFR16E(name, fulladdr) __sfr16 __at(fulladdr)                  name
           =1 # define SFR32(name, addr)      __sfr32 __at(((addr+3UL)<<24) | ((addr+2UL)<<16) | ((addr+1UL)<<8) | addr)
             - name
           =1 # define SFR32E(name, fulladdr) __sfr32 __at(fulladdr)                  name
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 # define INTERRUPT_PROTO(name, vector) void name (void) interrupt (vector)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void) interrupt (vector) using (regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using (regnum
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter) using (
             -regnum)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 4   

           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment at (addr) vartype name = init
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) locsegment at (addr) vartype name
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() _asm NOP _endasm
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Raisonance (must be placed before Keil C51)
           =1 // http://www.raisonance.com
           =1 
           =1 #elif defined __RC51__
           =1 
           =1 //#error Raisonance C51 detected.
           =1 
           =1 # define SEG_GENERIC generic     //SEG_GENERIC only applies to pointers in Raisonance, not variables.
           =1 # define SEG_FAR   xdata
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  data
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 5   

           =1 
           =1 # define SBIT(name, addr, bit)  at (addr+bit) sbit         name
           =1 # define SFR(name, addr)        sfr at addr                name
           =1 # define SFR16(name, addr)      sfr16 at addr              name
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) void name (void) interrupt vector
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO(name, vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) at addr locsegment vartype name
           =1 # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) at addr locsegment vartype name
           =1 
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 6   

           =1 
           =1 // NOP () macro support -- NOP is opcode 0x00
           =1 #define NOP() asm { 0x00 }
           =1 
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // Keil C51
           =1 // http://www.keil.com
           =1 
           =1 #elif defined __C51__
 307      =1  
 308      =1  //#error Keil C51 detected.
 309      =1  
 310      =1  # define SEG_GENERIC
 311      =1  # define SEG_FAR   xdata
 312      =1  # define SEG_DATA  data
 313      =1  # define SEG_NEAR  data
 314      =1  # define SEG_IDATA idata
 315      =1  # define SEG_XDATA xdata
 316      =1  # define SEG_PDATA pdata
 317      =1  # define SEG_CODE  code
 318      =1  # define SEG_BDATA bdata
 319      =1  
 320      =1  # define SBIT(name, addr, bit)  sbit  name = addr^bit
 321      =1  # define SFR(name, addr)        sfr   name = addr
 322      =1  # define SFR16(name, addr)      sfr16 name = addr
 323      =1  # define SFR16E(name, fulladdr) /* not supported */
 324      =1  # define SFR32(name, fulladdr)  /* not supported */
 325      =1  # define SFR32E(name, fulladdr) /* not supported */
 326      =1  
 327      =1  # define INTERRUPT(name, vector) void name (void) interrupt vector
 328      =1  # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
 329      =1  # define INTERRUPT_PROTO(name, vector) void name (void)
 330      =1  # define INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 331      =1  
 332      =1  # define FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter) using regnum
 333      =1  # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
 334      =1  // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
 335      =1  
 336      =1  # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
 337      =1  # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
 338      =1  # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
 339      =1  # define SEGMENT_POINTER(name, vartype, locsegment) vartype * locsegment name
 340      =1  # define LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype locsegment name _at_ addr
 341      =1  
 342      =1  // used with UU16
 343      =1  # define LSB 1
 344      =1  # define MSB 0
 345      =1  
 346      =1  // used with UU32 (b0 is least-significant byte)
 347      =1  //# define b0 3
 348      =1  // define b1 2
 349      =1  //# define b2 1
 350      =1  //# define b3 0
 351      =1  
 352      =1  typedef unsigned char U8;
 353      =1  typedef unsigned int U16;
 354      =1  typedef unsigned long U32;
 355      =1  
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 7   

 356      =1  typedef signed char S8;
 357      =1  typedef signed int S16;
 358      =1  typedef signed long S32;
 359      =1  
 360      =1  typedef union UU16
 361      =1  {
 362      =1     U16 U16;
 363      =1     S16 S16;
 364      =1     U8 U8[2];
 365      =1     S8 S8[2];
 366      =1  } UU16;
 367      =1  
 368      =1  typedef union UU32
 369      =1  {
 370      =1     U32 U32;
 371      =1     S32 S32;
 372      =1     UU16 UU16[2];
 373      =1     U16 U16[2];
 374      =1     S16 S16[2];
 375      =1     U8 U8[4];
 376      =1     S8 S8[4];
 377      =1  } UU32;
 378      =1  
 379      =1  // NOP () macro support
 380      =1  extern void _nop_ (void);
 381      =1  #define NOP() _nop_()
 382      =1  
 383      =1  //-----------------------------------------------------------------------------
 384      =1  
 385      =1  // Hi-Tech 8051
 386      =1  // http://www.htsoft.com
 387      =1  
 388      =1  #elif defined HI_TECH_C
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   far
           =1 # define SEG_DATA  data
           =1 # define SEG_NEAR  near
           =1 # define SEG_IDATA idata
           =1 # define SEG_XDATA xdata
           =1 # define SEG_PDATA pdata
           =1 # define SEG_CODE  code
           =1 # define SEG_BDATA bdata
           =1 
           =1 
           =1 # define SBIT(name, addr, thebit) static volatile bit name @ (addr + thebit)
           =1 # define SFR(name, addr)          static volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)        static volatile unsigned int name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector)       void name (void) interrupt vector
           =1 # define INTERRUPT_PROTO(name, vector)
           =1 # define INTERRUPT_USING(name, vector, regnum) void name (void) interrupt vector using regnum
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: Hi-Tech does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 8   

           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) targsegment vartype * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) targsegment vartype * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 # define b0 0
           =1 # define b1 1
           =1 # define b2 2
           =1 # define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 #define NOP() asm(" nop ")
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Tasking / Altium
           =1 // http://www.altium.com/tasking
           =1 
           =1 
           =1 #elif defined _CC51
           =1 
           =1 # define SEG_GENERIC
           =1 # define SEG_FAR   _xdat
           =1 # define SEG_DATA  _data
           =1 # define SEG_NEAR  _data
           =1 # define SEG_IDATA _idat
           =1 # define SEG_XDATA _xdat
           =1 # define SEG_PDATA _pdat
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 9   

           =1 # define SEG_CODE  _rom
           =1 # define SEG_BDATA _bdat
           =1 
           =1 # define SBIT(name, addr, bit)  _sfrbit  name _at(addr+bit)
           =1 # define SFR(name, addr)        _sfrbyte name _at(addr)
           =1 # define SFRX(name, addr)       _xdat volatile unsigned char name _at(addr)
           =1 #if _CC51 > 71
           =1 # define SFR16(name, addr)      _sfrword _little name _at(addr)
           =1 #else
           =1 # define SFR16(name, addr)      /* not supported */
           =1 #endif
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define INTERRUPT(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 # define INTERRUPT_PROTO(name, vector) _interrupt (vector) void name (void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) _interrupt (vector) _using(regnum) void name (void)
           =1 
           =1 // When calling FUNCTION_USING in Tasking, the function must be called from an interrupt or Main which
           =1 // is also using the same register bank. If not, the compiler will generate an error.
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (parameter
             -)
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) _using(regnum) return_value name (par
             -ameter)
           =1 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment) vartype locsegment name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
             -csegment name
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) vartype locsegment name _at( addr )
           =1 
           =1 // used with UU16
           =1 # define LSB 1
           =1 # define MSB 0
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 3
           =1 //# define b1 2
           =1 //# define b2 1
           =1 //# define b3 0
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 10  

           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 // NOP () macro support
           =1 extern void _nop (void);
           =1 #define NOP() _nop()
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 
           =1 // IAR 8051
           =1 // http://www.iar.com
           =1 
           =1 #elif defined __ICC8051__
           =1 
           =1 #include <stdbool.h>
           =1 #include <intrinsics.h>
           =1 
           =1 # define SBIT(name, addr, bit)  __bit __no_init volatile bool name @ (addr+bit)
           =1 # define SFR(name, addr)        __sfr __no_init volatile unsigned char name @ addr
           =1 # define SFRX(name, addr)       __xdata __no_init volatile unsigned char name @ addr
           =1 # define SFR16(name, addr)      __sfr __no_init volatile unsigned int  name @ addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr) /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 # define SEG_GENERIC __generic
           =1 # define SEG_FAR  __xdata
           =1 # define SEG_DATA __data
           =1 # define SEG_NEAR __data
           =1 # define SEG_IDATA __idata
           =1 # define SEG_XDATA __xdata
           =1 # define SEG_PDATA __pdata
           =1 # define SEG_CODE  __code
           =1 # define SEG_BDATA __bdata
           =1 
           =1 #define bit bool
           =1 
           =1 # define _PPTOSTR_(x) #x
           =1 # define _PPARAM_(address) _PPTOSTR_(vector=address * 8 + 3)
           =1 # define _PPARAM2_(regbank) _PPTOSTR_(register_bank=regbank)
           =1 # define INTERRUPT(name, vector) _Pragma(_PPARAM_(vector)) __interrupt void name(void)
           =1 # define INTERRUPT_PROTO(name, vector)  __interrupt void name(void)
           =1 # define INTERRUPT_USING(name, vector, regnum) _Pragma(_PPARAM2_(regnum)) _Pragma(_PPARAM_(vector)) __inte
             -rrupt void name(void)
           =1 # define INTERRUPT_PROTO_USING(name, vector, regnum) __interrupt void name(void)
           =1 
           =1 # define FUNCTION_USING(name, return_value, parameter, regnum) /* not supported */
           =1 # define FUNCTION_PROTO_USING(name, return_value, parameter, regnum) /* not supported */
           =1 // Note: IAR does not support functions using different register banks. Register
           =1 //       banks can only be specified in interrupts. If a function is called from
           =1 //       inside an interrupt, it will use the same register bank as the interrupt.
           =1 
           =1 # define SEGMENT_VARIABLE(name, vartype, locsegment)  locsegment vartype name
           =1 # define VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype targsegment  * name
           =1 # define SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype targsegment * lo
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 11  

             -csegment name
           =1 
           =1 # define LOCATED_VARIABLE(name, vartype, locsegment, addr, init) locsegment __no_init vartype name @ addr
           =1 
           =1 // used with UU16
           =1 # define LSB 0
           =1 # define MSB 1
           =1 
           =1 // used with UU32 (b0 is least-significant byte)
           =1 //# define b0 0
           =1 //# define b1 1
           =1 //# define b2 2
           =1 //# define b3 3
           =1 
           =1 typedef unsigned char U8;
           =1 typedef unsigned int U16;
           =1 typedef unsigned long U32;
           =1 
           =1 typedef signed char S8;
           =1 typedef signed int S16;
           =1 typedef signed long S32;
           =1 
           =1 typedef union UU16
           =1 {
           =1    U16 U16;
           =1    S16 S16;
           =1    U8 U8[2];
           =1    S8 S8[2];
           =1 } UU16;
           =1 
           =1 typedef union UU32
           =1 {
           =1    U32 U32;
           =1    S32 S32;
           =1    UU16 UU16[2];
           =1    U16 U16[2];
           =1    S16 S16[2];
           =1    U8 U8[4];
           =1    S8 S8[4];
           =1 } UU32;
           =1 
           =1 
           =1 #define NOP() __no_operation();
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Crossware
           =1 // http://www.crossware.com
           =1 
           =1 #elif defined _XC51_VER
           =1 # define SBIT(name, addr, bit)  _sfrbit  name = (addr+bit)
           =1 # define SFR(name, addr)        _sfr     name = addr
           =1 # define SFR16(name, addr)      _sfrword name = addr
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Wickenhäuser
           =1 // http://www.wickenhaeuser.de
           =1 
           =1 #elif defined __UC__
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 12  

           =1 # define SBIT(name, addr, bit)  unsigned char bit  name @ (addr+bit)
           =1 # define SFR(name, addr)        near unsigned char name @ addr
           =1 # define SFR16(name, addr)      /* not supported */
           =1 # define SFR16E(name, fulladdr) /* not supported */
           =1 # define SFR32(name, fulladdr)  /* not supported */
           =1 # define SFR32E(name, fulladdr) /* not supported */
           =1 
           =1 //-----------------------------------------------------------------------------
           =1 
           =1 // Default
           =1 // Unknown compiler
           =1 
           =1 #else
           =1 # warning unrecognized compiler
           =1 # define SBIT(name, addr, bit)  volatile bool           name
           =1 # define SFR(name, addr)        volatile unsigned char  name
           =1 # define SFRX(name, addr)       volatile unsigned char  name
           =1 # define SFR16(name, addr)      volatile unsigned short name
           =1 # define SFR16E(name, fulladdr) volatile unsigned short name
           =1 # define SFR32(name, fulladdr)  volatile unsigned long  name
           =1 # define SFR32E(name, fulladdr) volatile unsigned long  name
           =1 
           =1 #endif
 683      =1  
 684      =1  //-----------------------------------------------------------------------------
 685      =1  // Header File PreProcessor Directive
 686      =1  //-----------------------------------------------------------------------------
 687      =1  
 688      =1  #endif                                 // #define COMPILER_DEFS_H
 689      =1  
 690      =1  //-----------------------------------------------------------------------------
 691      =1  // End Of File
 692      =1  //-----------------------------------------------------------------------------
   3          #include "C8051F580_defs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // C8051F580_defs.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Copyright 2008, Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Register/bit definitions for the C8051F58x family.
  10      =1  // **Important Note**: The compiler_defs.h header file should be included
  11      =1  // before including this header file.
  12      =1  //
  13      =1  // Target:         C8051F580/1/2/3/4/5/6/7,8/9-F590/1
  14      =1  // Tool chain:     Generic
  15      =1  // Command Line:   None
  16      =1  //
  17      =1  // Release 0.6 - 20 AUG 2012 (TP)
  18      =1  //    -Added #define for _XPAGE to provide support for SDCC memory paging
  19      =1  //     (pdata)
  20      =1  //
  21      =1  // Release 0.5 - 10 SEP 2011 (GP)
  22      =1  //    - Fixed SFR16 definition for CAN0IF2MC
  23      =1  //
  24      =1  // Release 0.4 - 08 OCT 2010 (TP)
  25      =1  //    - Fixed bit definitions for SCON0
  26      =1  //
  27      =1  // Release 0.3 - 01 APR 2009 (GP)
  28      =1  //    - Added SN0-SN3
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 13  

  29      =1  //
  30      =1  // Release 0.2 - 29 JUL 2008 (ADT)
  31      =1  //    - Added Timer 4 bit definitions
  32      =1  //
  33      =1  // Release 0.1 - 09 JUL 2008 (GP)
  34      =1  //    - Initial Revision
  35      =1  //
  36      =1  //-----------------------------------------------------------------------------
  37      =1  // Header File Preprocessor Directive
  38      =1  //-----------------------------------------------------------------------------
  39      =1  
  40      =1  #ifndef C8051F580_DEFS_H
  41      =1  #define C8051F580_DEFS_H
  42      =1  
  43      =1  //-----------------------------------------------------------------------------
  44      =1  // Page 0, Page 1 and Page F Registers
  45      =1  //-----------------------------------------------------------------------------
  46      =1  
  47      =1  SFR (P0, 0x80);                        // Port 0 Latch
  48      =1  SFR (SP, 0x81);                        // Stack Pointer
  49      =1  SFR (DPL, 0x82);                       // Data Pointer Low
  50      =1  SFR (DPH, 0x83);                       // Data Pointer High
  51      =1  SFR (SFR0CN, 0x84);                    // SFR Page Control
  52      =1  SFR (SFRNEXT, 0x85);                   // SFR stack next page
  53      =1  SFR (SFRLAST, 0x86);                   // SFR stack last page
  54      =1  SFR (PCON, 0x87);                      // Power Control
  55      =1  SFR (TCON, 0x88);                      // Timer/Counter Control
  56      =1  SFR (TMOD, 0x89);                      // Timer/Counter Mode
  57      =1  SFR (TL0, 0x8A);                       // Timer/Counter 0 Low
  58      =1  SFR (TL1, 0x8B);                       // Timer/Counter 1 Low
  59      =1  SFR (TH0, 0x8C);                       // Timer/Counter 0 High
  60      =1  SFR (TH1, 0x8D);                       // Timer/Counter 1 High
  61      =1  SFR (CKCON, 0x8E);                     // Clock Control
  62      =1  SFR (PSCTL, 0x8F);                     // Program Store R/W Control
  63      =1  SFR (CLKSEL, 0x8F);                    // System clock select
  64      =1  SFR (P1, 0x90);                        // Port 1 Latch
  65      =1  SFR (TMR3CN, 0x91);                    // Timer/Counter 3 Control
  66      =1  SFR (TMR5CN, 0x91);                    // Timer/Counter 5 Control
  67      =1  SFR (TMR3RLL, 0x92);                   // Timer/Counter 3 Reload Low
  68      =1  SFR (TMR5CAPL, 0x92);                  // Timer/Counter 5 Capture Low
  69      =1  SFR (TMR3RLH, 0x93);                   // Timer/Counter 3 Reload High
  70      =1  SFR (TMR5CAPH, 0x93);                  // Timer/Counter 5 Capture High
  71      =1  SFR (TMR3L, 0x94);                     // Timer/Counter 3 Low
  72      =1  SFR (TMR5L, 0x94);                     // Timer/Counter 5 Low
  73      =1  SFR (TMR3H, 0x95);                     // Timer/Counter 3 High
  74      =1  SFR (TMR5H, 0x95);                     // Timer/Counter 5 High
  75      =1  SFR (TMR5CF, 0x96);                    // Timer/Counter 5 Configuration
  76      =1  SFR (CLKMUL, 0x97);                    // Clock Multiplier
  77      =1  SFR (SCON0, 0x98);                     // UART0 Control
  78      =1  SFR (SCON1, 0x98);                     // UART1 Control
  79      =1  SFR (SBUF0, 0x99);                     // UART0 Data Buffer
  80      =1  SFR (SBUF1, 0x99);                     // UART1 Data Buffer
  81      =1  SFR (CPT0CN, 0x9A);                    // Comparator 0 Control
  82      =1  SFR (CPT2CN, 0x9A);                    // Comparator 2 Control
  83      =1  SFR (CPT0MD, 0x9B);                    // Comparator 0 Mode
  84      =1  SFR (CPT2MD, 0x9B);                    // Comparator 2 Mode
  85      =1  SFR (CPT0MX, 0x9C);                    // Comparator 0 Mux
  86      =1  SFR (CPT2MX, 0x9C);                    // Comparator 2 Mux
  87      =1  SFR (CPT1CN, 0x9D);                    // Comparator 1 Control
  88      =1  SFR (CPT1MD, 0x9E);                    // Comparator 0 Mode
  89      =1  SFR (OSCIFIN, 0x9E);                   // Internal Oscillator Fine Control
  90      =1  SFR (CPT1MX, 0x9F);                    // Comparator 1 Mux
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 14  

  91      =1  SFR (OSCXCN, 0x9F);                    // External Oscillator Control
  92      =1  SFR (P2, 0xA0);                        // Port 2 Latch
  93      =1  SFR (SPI0CFG, 0xA1);                   // SPI0 Configuration
  94      =1  SFR (OSCICN, 0xA1);                    // Internal Oscillator Control
  95      =1  SFR (SPI0CKR, 0xA2);                   // SPI0 Clock rate control
  96      =1  SFR (OSCICRS, 0xA2);                   // Internal Oscillator Coarse Control
  97      =1  SFR (SPI0DAT, 0xA3);                   // SPI0 Data Buffer
  98      =1  SFR (P0MDOUT, 0xA4);                   // Port 0 Output Mode
  99      =1  SFR (P1MDOUT, 0xA5);                   // Port 1 Output Mode
 100      =1  SFR (P2MDOUT, 0xA6);                   // Port 2 Output Mode
 101      =1  SFR (SFRPAGE, 0xA7);                   // SFR Page Select
 102      =1  SFR (IE, 0xA8);                        // Interrupt Enable
 103      =1  SFR (SMOD0, 0xA9);                     // Serial Port 0 Control
 104      =1  SFR (EMI0CN, 0xAA);                    // EMIF Control
 105      =1  SFR (EMI0TC, 0xAA);                    // EMIF Timing control
 106      =1  SFR (SBCON0, 0xAB);                    // UART0 Baud Rate Generator Control
 107      =1  SFR (SBRLL0, 0xAC);                    // UART0 Baud Rate Generator Low
 108      =1  SFR (SBRLH0, 0xAD);                    // UART0 Baud Rate Generator High
 109      =1  SFR (P3MAT, 0xAE);                     // Port 3 Match
 110      =1  SFR (P3MDOUT, 0xAE);                   // Port 3 Mode
 111      =1  SFR (P3MASK, 0xAF);                    // Port 3 Mask
 112      =1  SFR (P4MDOUT, 0xAF);                   // Port 4 Mode
 113      =1  SFR (P3, 0xB0);                        // Port 3 Latch
 114      =1  SFR (P2MAT, 0xB1);                     // Port 2 Match
 115      =1  SFR (P2MASK, 0xB2);                    // Port 2 Mask
 116      =1  SFR (EMI0CF, 0xB2);                    // EMIF Configuration
 117      =1  SFR (P4, 0xB5);                        // Port 4 Latch
 118      =1  SFR (FLSCL, 0xB6);                     // Flash Scale
 119      =1  SFR (FLKEY, 0xB7);                     // Flash access limit
 120      =1  SFR (IP, 0xB8);                        // Interrupt Priority
 121      =1  SFR (SMB0ADR, 0xB9);                   // SMBus0 Slave address
 122      =1  SFR (ADC0TK, 0xBA);                    // ADC0 Tracking Mode Select
 123      =1  SFR (SMB0ADM, 0xBA);                   // SMBus0 Address Mask
 124      =1  SFR (ADC0MX, 0xBB);                    // AMUX0 Channel select
 125      =1  SFR (ADC0CF, 0xBC);                    // AMUX0 Channel configuration
 126      =1  SFR (ADC0L, 0xBD);                     // ADC0 Data Low
 127      =1  SFR (ADC0H, 0xBE);                     // ADC0 Data High
 128      =1  SFR (SMB0CN, 0xC0);                    // SMBus0 Control
 129      =1  SFR (SMB0CF, 0xC1);                    // SMBus0 Configuration
 130      =1  SFR (SMB0DAT, 0xC2);                   // SMBus0 Data
 131      =1  SFR (ADC0GTL, 0xC3);                   // ADC0 Greater-Than Compare Low
 132      =1  SFR (ADC0GTH, 0xC4);                   // ADC0 Greater-Than Compare High
 133      =1  SFR (ADC0LTL, 0xC5);                   // ADC0 Less-Than Compare Word Low
 134      =1  SFR (ADC0LTH, 0xC6);                   // ADC0 Less-Than Compare Word High
 135      =1  SFR (XBR3, 0xC6);                      // Port I/O Crossbar Control 3
 136      =1  SFR (XBR2, 0xC7);                      // Port I/O Crossbar Control 2
 137      =1  SFR (TMR2CN, 0xC8);                    // Timer/Counter 2 Control
 138      =1  SFR (TMR4CN, 0xC8);                    // Timer/Counter 4 Control
 139      =1  SFR (REG0CN, 0xC9);                    // Regulator Control
 140      =1  SFR (LIN0CF, 0xC9);                    // LIN 0 Configuration
 141      =1  SFR (TMR4CF, 0xC9);                    // Timer/Counter 4 Configuration
 142      =1  SFR (TMR2RLL, 0xCA);                   // Timer/Counter 2 Reload Low
 143      =1  SFR (TMR4CAPL, 0xCA);                  // Timer/Counter 4 Capture Low
 144      =1  SFR (TMR2RLH, 0xCB);                   // Timer/Counter 2 Reload High
 145      =1  SFR (TMR4CAPH, 0xCB);                  // Timer/Counter 4 Capture High
 146      =1  SFR (TMR2L, 0xCC);                     // Timer/Counter 2 Low
 147      =1  SFR (TMR4L, 0xCC);                     // Timer/Counter 4 Low
 148      =1  SFR (TMR2H, 0xCD);                     // Timer/Counter 2 High
 149      =1  SFR (TMR4H, 0xCD);                     // Timer/Counter 4 High
 150      =1  SFR (PCA0CPL5, 0xCE);                  // PCA0 Capture 5 Low
 151      =1  SFR (PCA1CPL11, 0xCE);                 // PCA1 Capture 11 Low
 152      =1  SFR (PCA0CPH5, 0xCF);                  // PCA0 Capture 5 High
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 15  

 153      =1  SFR (PCA1CPH11, 0xCF);                 // PCA1 Capture 11 High
 154      =1  SFR (PSW, 0xD0);                       // Program Status Word
 155      =1  SFR (REF0CN, 0xD1);                    // Voltage Reference Control
 156      =1  SFR (LIN0DAT, 0xD2);                   // LIN0 Data
 157      =1  SFR (LIN0ADR, 0xD3);                   // LIN0 Address
 158      =1  SFR (P0SKIP, 0xD4);                    // Port 0 Skip
 159      =1  SFR (P1SKIP, 0xD5);                    // Port 1 Skip
 160      =1  SFR (P2SKIP, 0xD6);                    // Port 2 Skip
 161      =1  SFR (P3SKIP, 0xD7);                    // Port 3 Skip
 162      =1  SFR (PCA0CN, 0xD8);                    // PCA0 Control
 163      =1  SFR (PCA1CN, 0xD8);                    // PCA1 Control
 164      =1  SFR (PCA0MD, 0xD9);                    // PCA0 Mode
 165      =1  SFR (PCA1MD, 0xD9);                    // PCA1 Mode
 166      =1  SFR (PCA0PWM, 0xD9);                   // PCA0 PWM Control
 167      =1  SFR (PCA0CPM0, 0xDA);                  // PCA0 Module 0 Mode
 168      =1  SFR (PCA1CPM6, 0xDA);                  // PCA1 Module 6 Mode
 169      =1  SFR (PCA1PWM, 0xDA);                   // PCA1 PWM Control
 170      =1  SFR (PCA0CPM1, 0xDB);                  // PCA0 Module 1  Mode
 171      =1  SFR (PCA1CPM7, 0xDB);                  // PCA1 Module 7  Mode
 172      =1  SFR (PCA0CPM2, 0xDC);                  // PCA0 Module 2  Mode
 173      =1  SFR (PCA1CPM8, 0xDC);                  // PCA1 Module 8  Mode
 174      =1  SFR (PCA0CPM3, 0xDD);                  // PCA0 Module 3  Mode
 175      =1  SFR (PCA1CPM9, 0xDD);                  // PCA1 Module 9  Mode
 176      =1  SFR (PCA0CPM4, 0xDE);                  // PCA0 Module 4  Mode
 177      =1  SFR (PCA1CPM10, 0xDE);                  // PCA1 Module 10 Mode
 178      =1  SFR (PCA0CPM5, 0xDF);                  // PCA0 Module 5  Mode
 179      =1  SFR (PCA1CPM11, 0xDF);                  // PCA1 Module 11 Mode
 180      =1  SFR (ACC, 0xE0);                       // Accumulator
 181      =1  SFR (XBR0, 0xE1);                      // Port I/O Crossbar Control 0
 182      =1  SFR (XBR1, 0xE2);                      // Port I/O Crossbar Control 1
 183      =1  SFR (CCH0CN, 0xE3);                    // Cache control
 184      =1  SFR (IT01CF, 0xE4);                    // INT0/INT1 Configuration
 185      =1  SFR (EIE1, 0xE6);                      // Extended Interrupt Enable 2
 186      =1  SFR (EIE2, 0xE7);                      // Extended Interrupt Enable 2
 187      =1  SFR (ADC0CN, 0xE8);                    // ADC0 Control
 188      =1  SFR (PCA0CPL1, 0xE9);                  // PCA0 Capture 1 Low
 189      =1  SFR (PCA1CPL1, 0xE9);                  // PCA1 Capture 7 Low
 190      =1  SFR (PCA0CPH1, 0xEA);                  // PCA0 Capture 1 High
 191      =1  SFR (PCA1CPH1, 0xEA);                  // PCA1 Capture 7 High
 192      =1  SFR (PCA0CPL2, 0xEB);                  // PCA0 Capture 2 Low
 193      =1  SFR (PCA1CPL2, 0xEB);                  // PCA1 Capture 8 Low
 194      =1  SFR (PCA0CPH2, 0xEC);                  // PCA0 Capture 2 High
 195      =1  SFR (PCA1CPH2, 0xEC);                  // PCA1 Capture 8 High
 196      =1  SFR (PCA0CPL3, 0xED);                  // PCA0 Capture 3 Low
 197      =1  SFR (PCA1CPL3, 0xED);                  // PCA1 Capture 9 Low
 198      =1  SFR (PCA0CPH3, 0xEE);                  // PCA0 Capture 3 High
 199      =1  SFR (PCA1CPH3, 0xEE);                  // PCA1 Capture 9 High
 200      =1  SFR (RSTSRC, 0xEF);                    // Reset Source Configuration/Status
 201      =1  SFR (B, 0xF0);                         // B Register
 202      =1  SFR (P0MAT, 0xF1);                     // Port 0 Match
 203      =1  SFR (P0MDIN, 0xF1);                    // Port 0 Input Mode
 204      =1  SFR (P0MASK, 0xF2);                    // Port 0 Mask
 205      =1  SFR (P1MDIN, 0xF2);                    // Port 1 Input Mode
 206      =1  SFR (P1MAT, 0xF3);                     // Port 1 Match
 207      =1  SFR (P2MDIN, 0xF3);                    // Port 2 Input Mode
 208      =1  SFR (P1MASK, 0xF4);                    // Port 1 Mask
 209      =1  SFR (P3MDIN, 0xF4);                    // Port 3 Input Mode
 210      =1  SFR (PSBANK, 0xF5);                    // Program Space Bank Select
 211      =1  SFR (EIP1, 0xF6);                      // External Interrupt Priority 1
 212      =1  SFR (EIP2, 0xF7);                      // External Interrupt Priority 2
 213      =1  SFR (SPI0CN, 0xF8);                    // SPI0 Control
 214      =1  SFR (PCA0L, 0xF9);                     // PCA0 Counter Low
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 16  

 215      =1  SFR (PCA1L, 0xF9);                     // PCA1 Counter Low
 216      =1  SFR (SN0, 0xF9);                       // Serial Number 0
 217      =1  SFR (PCA0H, 0xFA);                     // PCA0 Counter High
 218      =1  SFR (PCA1H, 0xFA);                     // PCA1 Counter High
 219      =1  SFR (SN1, 0xFA);                       // Serial Number 1
 220      =1  SFR (PCA0CPL0, 0xFB);                  // PCA0 Capture 0 Low
 221      =1  SFR (PCA1CPL6, 0xFB);                  // PCA1 Capture 6 Low
 222      =1  SFR (SN2, 0xFB);                       // Serial Number 2
 223      =1  SFR (PCA0CPH0, 0xFC);                  // PCA0 Capture 0 High
 224      =1  SFR (PCA1CPH6, 0xFC);                  // PCA1 Capture 6 High
 225      =1  SFR (SN3, 0xFC);                       // Serial Number 3
 226      =1  SFR (PCA0CPL4, 0xFD);                  // PCA0 Capture 4 Low
 227      =1  SFR (PCA1CPL10, 0xFD);                 // PCA1 Capture 10 Low
 228      =1  SFR (PCA0CPH4, 0xFE);                  // PCA0 Capture 4 High
 229      =1  SFR (PCA1CPH10, 0xFE);                 // PCA1 Capture 10 High
 230      =1  SFR (VDM0CN, 0xFF);                    // VDD Monitor Control
 231      =1  
 232      =1  //-----------------------------------------------------------------------------
 233      =1  // Page C (CAN0) Registers
 234      =1  //-----------------------------------------------------------------------------
 235      =1  
 236      =1  SFR (CAN0CFG, 0x92);                   // CAN0 Clock Configuration
 237      =1  SFR (CAN0STAT, 0x94);                  // Status Register Low Byte
 238      =1  SFR (CAN0ERRL, 0x96);                  // Error Counter Low Byte
 239      =1  SFR (CAN0ERRH, 0x97);                  // Error Counter High Byte
 240      =1  SFR (CAN0BTL, 0x9A);                   // Bit Timing Register Low Byte
 241      =1  SFR (CAN0BTH, 0x9B);                   // Bit Timing Register High Byte
 242      =1  SFR (CAN0IIDL, 0x9C);                  // Interrupt Register Low Byte
 243      =1  SFR (CAN0IIDH, 0x9D);                  // Interrupt Register High Byte
 244      =1  SFR (CAN0TST, 0x9E);                   // Test Register Low Byte
 245      =1  SFR (CAN0BRPE, 0xA1);                  // BRP Extension Register Low Byte
 246      =1  SFR (CAN0TR1L, 0xA2);                  // Transmission Request 1 Low Byte
 247      =1  SFR (CAN0TR1H, 0xA3);                  // Transmission Request 1 High Byte
 248      =1  SFR (CAN0TR2L, 0xA4);                  // Transmission Request 2 Low Byte
 249      =1  SFR (CAN0TR2H, 0xA5);                  // Transmission Request 2 High Byte
 250      =1  SFR (CAN0ND1L, 0xAA);                  // New Data 1 Low Byte
 251      =1  SFR (CAN0ND1H, 0xAB);                  // New Data 1 High Byte
 252      =1  SFR (CAN0ND2L, 0xAC);                  // New Data 2 Low Byte
 253      =1  SFR (CAN0ND2H, 0xAD);                  // New Data 2 High Byte
 254      =1  SFR (CAN0IP1L, 0xAE);                  // Interrupt Pending 1 Low Byte
 255      =1  SFR (CAN0IP1H, 0xAF);                  // Interrupt Pending 1 High Byte
 256      =1  SFR (CAN0IP2L, 0xB2);                  // Interrupt Pending 2 Low Byte
 257      =1  SFR (CAN0IP2H, 0xB3);                  // Interrupt Pending 2 High Byte
 258      =1  SFR (CAN0MV1L, 0xBA);                  // Message Valid 1 Low Byte
 259      =1  SFR (CAN0MV1H, 0xBB);                  // Message Valid 1 High Byte
 260      =1  SFR (CAN0MV2L, 0xBC);                  // Message Valid 2 Low Byte
 261      =1  SFR (CAN0MV2H, 0xBD);                  // Message Valid 2 High Byte
 262      =1  SFR (CAN0IF1CRL, 0xBE);                // IF1 Command Request Low Byte
 263      =1  SFR (CAN0IF1CRH, 0xBF);                // IF1 Command Request High Byte
 264      =1  SFR (CAN0CN, 0xC0);                    // CAN Control Register Low Byte
 265      =1  SFR (CAN0IF1CML, 0xC2);                // IF1 Command Mask Low Byte
 266      =1  SFR (CAN0IF1CMH, 0xC3);                // IF1 Command Mask High Byte
 267      =1  SFR (CAN0IF1M1L, 0xC4);                // IF1 Mask 1 Low Byte
 268      =1  SFR (CAN0IF1M1H, 0xC5);                // IF1 Mask 1 High Byte
 269      =1  SFR (CAN0IF1M2L, 0xC6);                // IF1 Mask 2 Low Byte
 270      =1  SFR (CAN0IF1M2H, 0xC7);                // IF1 Mask 2 High Byte
 271      =1  SFR (CAN0IF1A1L, 0xCA);                // IF1 Arbitration 1 Low Byte
 272      =1  SFR (CAN0IF1A1H, 0xCB);                // IF1 Arbitration 1 High Byte
 273      =1  SFR (CAN0IF1A2L, 0xCC);                // IF1 Arbitration 2 Low Byte
 274      =1  SFR (CAN0IF1A2H, 0xCD);                // IF1 Arbitration 2 High Byte
 275      =1  SFR (CAN0IF2MCL, 0xCE);                // IF2 Message Control Low Byte
 276      =1  SFR (CAN0IF2MCH, 0xCF);                // IF2 Message Control High Byte
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 17  

 277      =1  SFR (CAN0IF1MCL, 0xD2);                // IF1 Message Control Low Byte
 278      =1  SFR (CAN0IF1MCH, 0xD3);                // IF1 Message Control High Byte
 279      =1  SFR (CAN0IF1DA1L, 0xD4);               // IF1 Data A 1 Low Byte
 280      =1  SFR (CAN0IF1DA1H, 0xD5);               // IF1 Data A 1 High Byte
 281      =1  SFR (CAN0IF1DA2L, 0xD6);               // IF1 Data A 2 Low Byte
 282      =1  SFR (CAN0IF1DA2H, 0xD7);               // IF1 Data A 2 High Byte
 283      =1  SFR (CAN0IF1DB1L, 0xDA);               // IF1 Data B 1 Low Byte
 284      =1  SFR (CAN0IF1DB1H, 0xDB);               // IF1 Data B 1 High Byte
 285      =1  SFR (CAN0IF1DB2L, 0xDC);               // IF1 Data B 2 Low Byte
 286      =1  SFR (CAN0IF1DB2H, 0xDD);               // IF1 Data B 2 High Byte
 287      =1  SFR (CAN0IF2CRL, 0xDE);                // IF2 Command Request Low Byte
 288      =1  SFR (CAN0IF2CRH, 0xDF);                // IF2 Command Request High Byte
 289      =1  SFR (CAN0IF2CML, 0xE2);                // IF2 Command Mask Low Byte
 290      =1  SFR (CAN0IF2CMH, 0xE3);                // IF2 Command Mask High Byte
 291      =1  SFR (CAN0IF2M1L, 0xEA);                // IF2 Mask 1 Low Byte
 292      =1  SFR (CAN0IF2M1H, 0xEB);                // IF2 Mask 1 High Byte
 293      =1  SFR (CAN0IF2M2L, 0xEC);                // IF2 Mask 2 Low Byte
 294      =1  SFR (CAN0IF2M2H, 0xED);                // IF2 Mask 2 High Byte
 295      =1  SFR (CAN0IF2A1L, 0xEE);                // IF2 Arbitration 1 Low Byte
 296      =1  SFR (CAN0IF2A1H, 0xEF);                // IF2 Arbitration 1 High Byte
 297      =1  SFR (CAN0IF2A2L, 0xF2);                // IF2 Arbitration 2 Low Byte
 298      =1  SFR (CAN0IF2A2H, 0xF3);                // IF2 Arbitration 2 High Byte
 299      =1  SFR (CAN0IF2DA1L, 0xF6);               // IF2 Data A 1 Low Byte
 300      =1  SFR (CAN0IF2DA1H, 0xF7);               // IF2 Data A 1 High Byte
 301      =1  SFR (CAN0IF2DA2L, 0xFA);               // IF2 Data A 2 Low Byte
 302      =1  SFR (CAN0IF2DA2H, 0xFB);               // IF2 Data A 2 High Byte
 303      =1  SFR (CAN0IF2DB1L, 0xFC);               // IF2 Data B 1 Low Byte
 304      =1  SFR (CAN0IF2DB1H, 0xFD);               // IF2 Data B 1 High Byte
 305      =1  SFR (CAN0IF2DB2L, 0xFE);               // IF2 Data B 2 Low Byte
 306      =1  SFR (CAN0IF2DB2H, 0xFF);               // IF2 Data B 2 High Byte
 307      =1  
 308      =1  
 309      =1  //-----------------------------------------------------------------------------
 310      =1  // 16-bit Register Definitions (might not be supported by all compilers)
 311      =1  //-----------------------------------------------------------------------------
 312      =1  
 313      =1  SFR16 (DP, 0x82);                      // Data Pointer
 314      =1  SFR16 (TMR3RL, 0x92);                  // Timer 3 Reload
 315      =1  SFR16 (TMR5CAP, 0x92);                 // Timer 5 Capture
 316      =1  SFR16 (TMR3, 0x94);                    // Timer 3 Capture / Reload
 317      =1  SFR16 (TMR5, 0x94);                    // Timer 5
 318      =1  SFR16 (SBRL0, 0xAC);                   // UART0 Reload
 319      =1  SFR16 (ADC0, 0xBD);                    // ADC0 data
 320      =1  SFR16 (ADC0GT, 0xC3);                  // ADC0 Greater Than Window
 321      =1  SFR16 (ADC0LT, 0xC5);                  // ADC0 Less Than Window
 322      =1  SFR16 (TMR2RL, 0xCA);                  // Timer 2 Reload
 323      =1  SFR16 (TMR4CAP, 0xCA);                 // Timer 4 Capture
 324      =1  SFR16 (TMR2, 0xCC);                    // Timer 2 Capture / Reload
 325      =1  SFR16 (TMR4, 0xCC);                    // Timer 4
 326      =1  SFR16 (PCA0CP5, 0xCE);                 // PCA0 Module 5 Capture
 327      =1  SFR16 (PCA1CP11, 0xCE);                // PCA1 Module 11 Capture
 328      =1  SFR16 (PCA0CP1, 0xE9);                 // PCA0 Module 1 Capture
 329      =1  SFR16 (PCA1CP7, 0xE9);                 // PCA1 Module 7 Capture
 330      =1  SFR16 (PCA0CP2, 0xEB);                 // PCA0 Module 2 Capture
 331      =1  SFR16 (PCA1CP8, 0xEB);                 // PCA1 Module 8 Capture
 332      =1  SFR16 (PCA0CP3, 0xED);                 // PCA0 Module 3 Capture
 333      =1  SFR16 (PCA1CP9, 0xED);                 // PCA1 Module 9 Capture
 334      =1  SFR16 (PCA0, 0xF9);                    // PCA0 Counter
 335      =1  SFR16 (PCA1, 0xF9);                    // PCA1 Counter
 336      =1  SFR16 (PCA0CP0, 0xFB);                 // PCA0 Module 0 Capture
 337      =1  SFR16 (PCA1CP6, 0xFB);                 // PCA1 Module 6 Capture
 338      =1  SFR16 (PCA0CP4, 0xFD);                 // PCA0 Module 4 Capture
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 18  

 339      =1  SFR16 (PCA1CP10, 0xFD);                 // PCA1 Module 10 Capture
 340      =1  
 341      =1  SFR16 (CAN0ERR, 0x96);                 // Error Counter
 342      =1  SFR16 (CAN0BT, 0x9A);                  // Bit Timing Register
 343      =1  SFR16 (CAN0IID, 0x9C);                 // Interrupt Register
 344      =1  SFR16 (CAN0TR1, 0xA2);                 // Transmission Request 1
 345      =1  SFR16 (CAN0TR2, 0xA4);                 // Transmission Request 2
 346      =1  SFR16 (CAN0ND1, 0xAA);                 // New Data 1
 347      =1  SFR16 (CAN0ND2, 0xAC);                 // New Data 2
 348      =1  SFR16 (CAN0IP1, 0xAE);                 // Interrupt Pending 1
 349      =1  SFR16 (CAN0IP2, 0xB2);                 // Interrupt Pending 2
 350      =1  SFR16 (CAN0MV1, 0xBA);                 // Message Valid 1
 351      =1  SFR16 (CAN0MV2, 0xBC);                 // Message Valid 2
 352      =1  SFR16 (CAN0IF1CR, 0xBE);               // IF1 Command Request
 353      =1  SFR16 (CAN0IF1CM, 0xC2);               // IF1 Command Mask
 354      =1  SFR16 (CAN0IF1M1, 0xC4);               // IF1 Mask 1
 355      =1  SFR16 (CAN0IF1M2, 0xC6);               // IF1 Mask 2
 356      =1  SFR16 (CAN0IF1A1, 0xCA);               // IF1 Arbitration 1
 357      =1  SFR16 (CAN0IF1A2, 0xCC);               // IF1 Arbitration 2
 358      =1  SFR16 (CAN0IF1MC, 0xD2);               // IF1 Message Control
 359      =1  SFR16 (CAN0IF1DA1, 0xD4);              // IF1 Data A 1
 360      =1  SFR16 (CAN0IF1DA2, 0xD6);              // IF1 Data A 2
 361      =1  SFR16 (CAN0IF1DB1, 0xDA);              // IF1 Data B 1
 362      =1  SFR16 (CAN0IF1DB2, 0xDC);              // IF1 Data B 2
 363      =1  SFR16 (CAN0IF2CR, 0xDE);               // IF2 Command Request
 364      =1  SFR16 (CAN0IF2CM, 0xE2);               // IF2 Command Mask
 365      =1  SFR16 (CAN0IF2M1, 0xEA);               // IF2 Mask 1
 366      =1  SFR16 (CAN0IF2M2, 0xEC);               // IF2 Mask 2
 367      =1  SFR16 (CAN0IF2A1, 0xEE);               // IF2 Arbitration 1
 368      =1  SFR16 (CAN0IF2A2, 0xF2);               // IF2 Arbitration 2
 369      =1  SFR16 (CAN0IF2MC, 0xCE);               // IF2 Message Control
 370      =1  SFR16 (CAN0IF2DA1, 0xF6);              // IF2 Data A 1
 371      =1  SFR16 (CAN0IF2DA2, 0xFA);              // IF2 Data A 2
 372      =1  SFR16 (CAN0IF2DB1, 0xFC);              // IF2 Data B 1
 373      =1  SFR16 (CAN0IF2DB2, 0xFE);              // IF2 Data B 2
 374      =1  
 375      =1  //-----------------------------------------------------------------------------
 376      =1  // LIN0 Indirect Registers
 377      =1  //-----------------------------------------------------------------------------
 378      =1  
 379      =1  #define  LIN0DT1   0x00                // LIN0 Data Byte 1
 380      =1  #define  LIN0DT2   0x01                // LIN0 Data Byte 2
 381      =1  #define  LIN0DT3   0x02                // LIN0 Data Byte 3
 382      =1  #define  LIN0DT4   0x03                // LIN0 Data Byte 4
 383      =1  #define  LIN0DT5   0x04                // LIN0 Data Byte 5
 384      =1  #define  LIN0DT6   0x05                // LIN0 Data Byte 6
 385      =1  #define  LIN0DT7   0x06                // LIN0 Data Byte 7
 386      =1  #define  LIN0DT8   0x07                // LIN0 Data Byte 8
 387      =1  #define  LIN0CTRL  0x08                // LIN0 Control
 388      =1  #define  LIN0ST    0x09                // LIN0 Status
 389      =1  #define  LIN0ERR   0x0A                // LIN0 Error
 390      =1  #define  LIN0SIZE  0x0B                // LIN0 Message Size
 391      =1  #define  LIN0DIV   0x0C                // LIN0 Divider
 392      =1  #define  LIN0MUL   0x0D                // LIN0 Multiplier
 393      =1  #define  LIN0ID    0x0E                // LIN0 Identifier
 394      =1  
 395      =1  //-----------------------------------------------------------------------------
 396      =1  // Address Definitions for Bit-addressable Registers
 397      =1  //-----------------------------------------------------------------------------
 398      =1  
 399      =1  #define SFR_P0       0x80
 400      =1  #define SFR_TCON     0x88
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 19  

 401      =1  #define SFR_P1       0x90
 402      =1  #define SFR_SCON0    0x98
 403      =1  #define SFR_SCON1    0x98
 404      =1  #define SFR_P2       0xA0
 405      =1  #define SFR_IE       0xA8
 406      =1  #define SFR_P3       0xB0
 407      =1  #define SFR_IP       0xB8
 408      =1  #define SFR_SMB0CN   0xC0
 409      =1  #define SFR_TMR2CN   0xC8
 410      =1  #define SFR_TMR4CN   0xC8
 411      =1  #define SFR_PSW      0xD0
 412      =1  #define SFR_PCA0CN   0xD8
 413      =1  #define SFR_PCA1CN   0xD8
 414      =1  #define SFR_ACC      0xE0
 415      =1  #define SFR_ADC0CN   0xE8
 416      =1  #define SFR_B        0xF0
 417      =1  #define SFR_SPI0CN   0xF8
 418      =1  
 419      =1  //-----------------------------------------------------------------------------
 420      =1  // Bit Definitions
 421      =1  //-----------------------------------------------------------------------------
 422      =1  
 423      =1  // TCON 0x88
 424      =1  SBIT (TF1, SFR_TCON, 7);               // Timer 1 Overflow Flag
 425      =1  SBIT (TR1, SFR_TCON, 6);               // Timer 1 On/Off Control
 426      =1  SBIT (TF0, SFR_TCON, 5);               // Timer 0 Overflow Flag
 427      =1  SBIT (TR0, SFR_TCON, 4);               // Timer 0 On/Off Control
 428      =1  SBIT (IE1, SFR_TCON, 3);               // Ext. Interrupt 1 Edge Flag
 429      =1  SBIT (IT1, SFR_TCON, 2);               // Ext. Interrupt 1 Type
 430      =1  SBIT (IE0, SFR_TCON, 1);               // Ext. Interrupt 0 Edge Flag
 431      =1  SBIT (IT0, SFR_TCON, 0);               // Ext. Interrupt 0 Type
 432      =1  
 433      =1  // SCON0 0x98
 434      =1  SBIT (OVR0, SFR_SCON0, 7);             // UART0 Receive FIFO Overrun Flag
 435      =1  SBIT (PERR0, SFR_SCON0, 6);            // UART0 Parity Error Flag
 436      =1  SBIT (THRE0, SFR_SCON0, 5);            // UART0 Transmit Register Empty Flag
 437      =1  SBIT (REN0, SFR_SCON0, 4);             // UART0 RX Enable
 438      =1  SBIT (TBX0, SFR_SCON0, 3);             // UART0 Extra Transmission Bit
 439      =1  SBIT (RBX0, SFR_SCON0, 2);             // UART0 Extra Receive Bit
 440      =1  SBIT (TI0, SFR_SCON0, 1);              // UART0 TX Interrupt Flag
 441      =1  SBIT (RI0, SFR_SCON0, 0);              // UART0 RX Interrupt Flag
 442      =1  
 443      =1  // SCON1 0x98
 444      =1  SBIT (S1MODE, SFR_SCON1, 7);           // UART1 Mode 0
 445      =1                                         // Bit 6 UNUSED
 446      =1  SBIT (MCE1, SFR_SCON1, 5);             // UART1 Multiprocessor enable
 447      =1  SBIT (REN1, SFR_SCON1, 4);             // UART1 RX Enable
 448      =1  SBIT (TB81, SFR_SCON1, 3);             // UART1 TX Bit 8
 449      =1  SBIT (RB81, SFR_SCON1, 2);             // UART1 RX Bit 8
 450      =1  SBIT (TI1, SFR_SCON1, 1);              // UART1 TX Interrupt Flag
 451      =1  SBIT (RI1, SFR_SCON1, 0);              // UART1 RX Interrupt Flag
 452      =1  
 453      =1  // IE 0xA8
 454      =1  SBIT (EA, SFR_IE, 7);                  // Global Interrupt Enable
 455      =1  SBIT (ESPI0, SFR_IE, 6);               // SPI0 Interrupt Enable
 456      =1  SBIT (ET2, SFR_IE, 5);                 // Timer 2 Interrupt Enable
 457      =1  SBIT (ES0, SFR_IE, 4);                 // UART0 Interrupt Enable
 458      =1  SBIT (ET1, SFR_IE, 3);                 // Timer 1 Interrupt Enable
 459      =1  SBIT (EX1, SFR_IE, 2);                 // External Interrupt 1 Enable
 460      =1  SBIT (ET0, SFR_IE, 1);                 // Timer 0 Interrupt Enable
 461      =1  SBIT (EX0, SFR_IE, 0);                 // External Interrupt 0 Enable
 462      =1  
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 20  

 463      =1  // IP 0xB8
 464      =1                                         // Bit 7 unused
 465      =1  SBIT (PSPI0, SFR_IP, 6);               // SPI0 Interrupt Priority
 466      =1  SBIT (PT2, SFR_IP, 5);                 // Timer 2 Priority
 467      =1  SBIT (PS0, SFR_IP, 4);                 // UART0 Priority
 468      =1  SBIT (PS, SFR_IP, 4);                  // UART0 Priority
 469      =1  SBIT (PT1, SFR_IP, 3);                 // Timer 1 Priority
 470      =1  SBIT (PX1, SFR_IP, 2);                 // External Interrupt 1 Priority
 471      =1  SBIT (PT0, SFR_IP, 1);                 // Timer 0 Priority
 472      =1  SBIT (PX0, SFR_IP, 0);                 // External Interrupt 0 Priority
 473      =1  
 474      =1  // SMB0CN 0xC0
 475      =1  SBIT (MASTER, SFR_SMB0CN, 7);          // SMBus0 Master/Slave Indicator
 476      =1  SBIT (TXMODE, SFR_SMB0CN, 6);          // SMBus0 Transmit Mode Indicator
 477      =1  SBIT (STA, SFR_SMB0CN, 5);             // SMBus0 Start Flag
 478      =1  SBIT (STO, SFR_SMB0CN, 4);             // SMBus0 Stop Flag
 479      =1  SBIT (ACKRQ, SFR_SMB0CN, 3);           // SMBus0 Acknowledge Request
 480      =1  SBIT (ARBLOST, SFR_SMB0CN, 2);         // SMBus0 Arbitration Lost Indicator
 481      =1  SBIT (ACK, SFR_SMB0CN, 1);             // SMBus0 Acknowledge
 482      =1  SBIT (SI, SFR_SMB0CN, 0);              // SMBus0 Interrupt Flag
 483      =1  
 484      =1  // TMR2CN 0xC8
 485      =1  SBIT (TF2H, SFR_TMR2CN, 7);            // Timer 2 High-Byte Overflow Flag
 486      =1  SBIT (TF2L, SFR_TMR2CN, 6);            // Timer 2 Low-Byte  Overflow Flag
 487      =1  SBIT (TF2LEN, SFR_TMR2CN, 5);          // Timer 2 Low-Byte Flag Enable
 488      =1  SBIT (TF2CEN, SFR_TMR2CN, 4);          // Timer 2 Capture Enable
 489      =1  SBIT (T2SPLIT, SFR_TMR2CN, 3);         // Timer 2 Split-Mode Enable
 490      =1  SBIT (TR2, SFR_TMR2CN, 2);             // Timer 2 Run Enable
 491      =1  SBIT (T2RCLK, SFR_TMR2CN, 1);          // Timer 2 Xclk/Rclk Select
 492      =1  SBIT (T2XCLK, SFR_TMR2CN, 0);          // Timer 2 Clk/8 Clock Source
 493      =1  
 494      =1  // TMR4CN 0xC8
 495      =1  SBIT (TF4, SFR_TMR4CN, 7);             // Timer 4 Overflow/Underflow Flag
 496      =1  SBIT (EXF4, SFR_TMR4CN, 6);            // Timer 4 External Flag
 497      =1                                         // Bit 5 unused
 498      =1                                         // Bit 4 unused
 499      =1  SBIT (EXE4, SFR_TMR4CN, 3);            // Timer 4 External Enable
 500      =1  SBIT (TR4, SFR_TMR4CN, 2);             // Timer 4 Run Enable
 501      =1  SBIT (CT4, SFR_TMR4CN, 1);             // Timer 4 Counter/Timer Select
 502      =1  SBIT (CPRL4, SFR_TMR4CN, 0);           // Timer 4 Capture/Reload Select
 503      =1  
 504      =1  // PSW 0xD0
 505      =1  SBIT (CY, SFR_PSW, 7);                 // Carry Flag
 506      =1  SBIT (AC, SFR_PSW, 6);                 // Auxiliary Carry Flag
 507      =1  SBIT (F0, SFR_PSW, 5);                 // User Flag 0
 508      =1  SBIT (RS1, SFR_PSW, 4);                // Register Bank Select 1
 509      =1  SBIT (RS0, SFR_PSW, 3);                // Register Bank Select 0
 510      =1  SBIT (OV, SFR_PSW, 2);                 // Overflow Flag
 511      =1  SBIT (F1, SFR_PSW, 1);                 // User Flag 1
 512      =1  SBIT (P, SFR_PSW, 0);                  // Accumulator Parity Flag
 513      =1  
 514      =1  // PCA0CN 0xD8
 515      =1  SBIT (CF, SFR_PCA0CN, 7);              // PCA0 Counter Overflow Flag
 516      =1  SBIT (CR, SFR_PCA0CN, 6);              // PCA0 Counter Run Control Bit
 517      =1  SBIT (CCF5, SFR_PCA0CN, 5);            // PCA0 Module 5 Interrupt Flag
 518      =1  SBIT (CCF4, SFR_PCA0CN, 4);            // PCA0 Module 4 Interrupt Flag
 519      =1  SBIT (CCF3, SFR_PCA0CN, 3);            // PCA0 Module 3 Interrupt Flag
 520      =1  SBIT (CCF2, SFR_PCA0CN, 2);            // PCA0 Module 2 Interrupt Flag
 521      =1  SBIT (CCF1, SFR_PCA0CN, 1);            // PCA0 Module 1 Interrupt Flag
 522      =1  SBIT (CCF0, SFR_PCA0CN, 0);            // PCA0 Module 0 Interrupt Flag
 523      =1  
 524      =1  // PCA1CN 0xD8
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 21  

 525      =1  SBIT (CF1, SFR_PCA1CN, 7);             // PCA1 Counter Overflow Flag
 526      =1  SBIT (CR1, SFR_PCA1CN, 6);             // PCA1 Counter Run Control Bit
 527      =1  SBIT (CCF11, SFR_PCA1CN, 5);           // PCA1 Module 11 Interrupt Flag
 528      =1  SBIT (CCF10, SFR_PCA1CN, 4);           // PCA1 Module 10 Interrupt Flag
 529      =1  SBIT (CCF9, SFR_PCA1CN, 3);            // PCA1 Module 9 Interrupt Flag
 530      =1  SBIT (CCF8, SFR_PCA1CN, 2);            // PCA1 Module 8 Interrupt Flag
 531      =1  SBIT (CCF7, SFR_PCA1CN, 1);            // PCA1 Module 7 Interrupt Flag
 532      =1  SBIT (CCF6, SFR_PCA1CN, 0);            // PCA1 Module 6 Interrupt Flag
 533      =1  
 534      =1  // ADC0CN 0xE8
 535      =1  SBIT (AD0EN, SFR_ADC0CN, 7);           // ADC0 Enable
 536      =1  SBIT (BURSTEN, SFR_ADC0CN, 6);         // ADC0 Burst Enable
 537      =1  SBIT (AD0INT, SFR_ADC0CN, 5);          // ADC0 EOC Interrupt Flag
 538      =1  SBIT (AD0BUSY, SFR_ADC0CN, 4);         // ADC0 Busy Flag
 539      =1  SBIT (AD0WINT, SFR_ADC0CN, 3);         // ADC0 Window Compare Interrupt Flag
 540      =1  SBIT (AD0LJST, SFR_ADC0CN, 2);         // ADC0 Left Justified
 541      =1  SBIT (AD0CM1, SFR_ADC0CN, 1);          // ADC0 Start Of Conversion Mode Bit 1
 542      =1  SBIT (AD0CM0, SFR_ADC0CN, 0);          // ADC0 Start Of Conversion Mode Bit 0
 543      =1  
 544      =1  // SPI0CN 0xF8
 545      =1  SBIT (SPIF, SFR_SPI0CN, 7);            // SPI0 Interrupt Flag
 546      =1  SBIT (WCOL, SFR_SPI0CN, 6);            // SPI0 Write Collision Flag
 547      =1  SBIT (MODF, SFR_SPI0CN, 5);            // SPI0 Mode Fault Flag
 548      =1  SBIT (RXOVRN, SFR_SPI0CN, 4);          // SPI0 RX Overrun Flag
 549      =1  SBIT (NSSMD1, SFR_SPI0CN, 3);          // SPI0 Slave Select Mode 1
 550      =1  SBIT (NSSMD0, SFR_SPI0CN, 2);          // SPI0 Slave Select Mode 0
 551      =1  SBIT (TXBMT, SFR_SPI0CN, 1);           // SPI0 TX Buffer Empty Flag
 552      =1  SBIT (SPIEN, SFR_SPI0CN, 0);           // SPI0 Enable
 553      =1  
 554      =1  //-----------------------------------------------------------------------------
 555      =1  // Interrupt Priorities
 556      =1  //-----------------------------------------------------------------------------
 557      =1  
 558      =1  #define INTERRUPT_INT0             0   // External Interrupt 0
 559      =1  #define INTERRUPT_TIMER0           1   // Timer 0 Overflow
 560      =1  #define INTERRUPT_INT1             2   // External Interrupt 1
 561      =1  #define INTERRUPT_TIMER1           3   // Timer 1 Overflow
 562      =1  #define INTERRUPT_UART0            4   // UART0
 563      =1  #define INTERRUPT_TIMER2           5   // Timer 2 Overflow
 564      =1  #define INTERRUPT_SPI0             6   // SPI0
 565      =1  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 566      =1  #define INTERRUPT_ADC0_WINDOW      8   // ADC0 Window Comparison
 567      =1  #define INTERRUPT_ADC0_EOC         9   // ADC0 End Of Conversion
 568      =1  #define INTERRUPT_PCA0            10   // PCA0 Peripheral
 569      =1  #define INTERRUPT_COMPARATOR0     11   // Comparator 0 Comparison
 570      =1  #define INTERRUPT_COMPARATOR1     12   // Comparator 1 Comparison
 571      =1  #define INTERRUPT_TIMER3          13   // Timer 3 Overflow
 572      =1  #define INTERRUPT_LIN0            14   // LIN Bus Interrupt
 573      =1  #define INTERRUPT_VREG            15   // Voltage Regulator
 574      =1  #define INTERRUPT_CAN0            16   // CAN Bus Interrupt
 575      =1  #define INTERRUPT_PORT_MATCH      17   // Port Match
 576      =1  #define INTERRUPT_UART1           18   // UART1
 577      =1  #define INTERRUPT_PCA1            19   // PCA1 Peripheral
 578      =1  #define INTERRUPT_COMPARATOR2     20   // Comparator 2 Comparison
 579      =1  #define INTERRUPT_TIMER4          21   // Timer 4 Overflow
 580      =1  #define INTERRUPT_TIMER5          22   // Timer 5 Overflow
 581      =1  
 582      =1  
 583      =1  //-----------------------------------------------------------------------------
 584      =1  // SFR Page Definitions
 585      =1  //-----------------------------------------------------------------------------
 586      =1  
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 22  

 587      =1  #define  CONFIG_PAGE       0x0F        // System and Port Configuration Page
 588      =1  #define  ACTIVE_PAGE       0x00        // Active Use Page
 589      =1  #define  ACTIVE2_PAGE      0x10        // Active Use Page 2
 590      =1  #define  CAN0_PAGE         0x0C        // CAN0 Registers
 591      =1  
 592      =1  //-----------------------------------------------------------------------------
 593      =1  // SDCC PDATA External Memory Paging Support
 594      =1  //-----------------------------------------------------------------------------
 595      =1  
 596      =1  #if defined SDCC
           =1 
           =1 SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =1 
           =1 #endif
 601      =1  
 602      =1  //-----------------------------------------------------------------------------
 603      =1  // Header File PreProcessor Directive
 604      =1  //-----------------------------------------------------------------------------
 605      =1  
 606      =1  #endif                                 // #define C8051F580_DEFS_H
 607      =1  
 608      =1  //-----------------------------------------------------------------------------
 609      =1  // End Of File
 610      =1  //-----------------------------------------------------------------------------
   4          #include "Global_Define.h"
   1      =1  /*----------TYPE-------------------*/
   2      =1  
   3      =1  #define CAMERA
   4      =1  #define SYSCLK 24000000
   5      =1  /*----------SENSOR-----------------*/
   6      =1  
   7      =1  //      #define APTINA_126
   8      =1  //      #define APTINA_128
   9      =1          #define APTINA_AP0100                   0x03U
  10      =1          #define APTINA_ASX344                   0x04U
  11      =1  //      #define APTINA_ASX350AT
  12      =1  
  13      =1  
  14      =1  /*----------EEPROM-----------------*/
  15      =1  #define MXIC
  16      =1  //#define WINBOND
  17      =1  
  18      =1  /*----------DEVICE-----------------*/
  19      =1  //#define UART
  20      =1  #define SPI
  21      =1  #define I2C                                                     
  22      =1  #define ADC
  23      =1  #define WATCHDOG
  24      =1  #define PCA
  25      =1  #define CAN
  26      =1  
  27      =1  #define EXINTERRUPT
  28      =1  
  29      =1  /*----------I2C---------------*/        // Use Timer1
  30      =1  //#define I2C_SPEED_100KHZ                      
  31      =1  #define I2C_SPEED_400KHZ                
  32      =1  
  33      =1  /*----------WATCHDOG---------------*/
  34      =1  #define WATCHDOG_ENABLE
  35      =1  //#define WATCHDOG_32MS
  36      =1  #define WATCHDOG_400MS
  37      =1  
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 23  

  38      =1  /*----------VDDMONITOR-------------*/
  39      =1  #define VDDMONITOR_ENABLE
  40      =1  //#define VDDMONITOR_HIGH
  41      =1  #define VDDMONITOR_LOW
  42      =1  
  43      =1  /*----------TIMER-------------*/
  44      =1  //#define TIMER0                                        //Use Wait_ms()
  45      =1  #define TIMER1                                          //Use SMBUS0
  46      =1  //#define TIMER2                                                //1ms interrupt1
  47      =1  //#define TIMER3                                                //Use SMBUS0 low time out
  48      =1  //#define TIMER4                                        //1ms interrupt2
  49      =1  #define TIMER5                                          //Use PCA0 (Watchdog)
  50      =1  
  51      =1  /*----------ETC..-----------------*/
  52      =1  #define TRUE    (U8)1
  53      =1  #define FALSE   (U8)0
  54      =1  
  55      =1  #define HIGH    (U8)1
  56      =1  #define LOW     (U8)0
  57      =1  
  58      =1  //CAN DATA
  59      =1  //#define MDPS11                                
  60      =1  //#define LANGUAGEINFO          
  61      =1  //#define HUTYPE                                
  62      =1  //#define GATEWAY                               
  63      =1  //#define NAVIONOFF                     
  64      =1  //#define G_SEL_DISP                
  65      =1  //#define CAM_REARCAMERA_REQ    
  66      =1  
  67      =1  //Operate Mode---------------------
  68      =1  #define OPERATE_STANDBY         (U8)1
  69      =1  #define OPERATE_INTERINIT       (U8)2
  70      =1  #define OPERATE_IDLE            (U8)3
  71      =1  #define OPERATE_RUNNING         (U8)4
  72      =1  
  73      =1  #define DTC_RECORD_WRITE
  74      =1  #define DTC_RECORD_CLEAR
  75      =1  
  76      =1  //Define Error
  77      =1  #define NO_ERROR                        (U8)0x00
  78      =1  #define ERROR_RX_COMM           (U8)0x01        //RX Error
  79      =1  #define ERROR_TX_COMM           (U8)0x02        //TX Error
  80      =1  
  81      =1  //#define ERROR_TX_COMM         (U8)0x02        //RX Error
  82      =1  
  83      =1  #define OPERATION_MODE_FIRMWARE    //firmware
  84      =1  //#define OPERATION_MODE_DOWNLOAD    //tuning
  85      =1  
  86      =1  //BANK SET
  87      =1  #define BANK0                           (U8)0x00
  88      =1  #define BANK1                           (U8)0x10
  89      =1  #define BANK2                           (U8)0x20
  90      =1  #define BANK3                           (U8)0x30
  91      =1  //DIAGNOSTIC TEST
  92      =1  //#define DIAG_TEST_MCU_WD_ERR
  93      =1  //#define DIAG_TEST_MCU_MC_ERR
  94      =1  //#define DIAG_TEST_ISP_FV_ERR
  95      =1  //#define DIAG_TEST_ISP_FC_ERR
  96      =1  //#define DIAG_TEST_ISP_IS_ERR
  97      =1  //#define DIAG_TEST_ISP_CM_ERR
  98      =1  //#define DIAG_TEST_ISP_IT_ERR
  99      =1  //#define DIAG_TEST_VID_OC_ERR
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 24  

 100      =1  //#define DIAG_TEST_VID_VO_ERR
 101      =1  
   5          #include <stdio.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDIO.H
   3      =1  
   4      =1  Prototypes for standard I/O functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDIO_H__
  10      =1  #define __STDIO_H__
  11      =1  
  12      =1  #ifndef EOF
  13      =1   #define EOF -1
  14      =1  #endif
  15      =1  
  16      =1  #ifndef NULL
  17      =1   #define NULL ((void *) 0)
  18      =1  #endif
  19      =1  
  20      =1  #ifndef _SIZE_T
  21      =1   #define _SIZE_T
  22      =1   typedef unsigned int size_t;
  23      =1  #endif
  24      =1  
  25      =1  #pragma SAVE
  26      =1  #pragma REGPARMS
  27      =1  extern char _getkey (void);
  28      =1  extern char getchar (void);
  29      =1  extern char ungetchar (char);
  30      =1  extern char putchar (char);
  31      =1  extern int printf   (const char *, ...);
  32      =1  extern int sprintf  (char *, const char *, ...);
  33      =1  extern int vprintf  (const char *, char *);
  34      =1  extern int vsprintf (char *, const char *, char *);
  35      =1  extern char *gets (char *, int n);
  36      =1  extern int scanf (const char *, ...);
  37      =1  extern int sscanf (char *, const char *, ...);
  38      =1  extern int puts (const char *);
  39      =1  
  40      =1  #pragma RESTORE
  41      =1  
  42      =1  #endif
  43      =1  
   6          #include "drv_spi.h"
   1      =1  #ifndef DRV_SPI_H
   2      =1  #define DRV_SPI_H
   3      =1  
   4      =1  // Target MCU Commands
   5      =1  #define TGT_CMD_ENTER_BL_MODE    (0x90U)
   6      =1  #define TGT_CMD_GET_INFO         (0x91U)
   7      =1  #define TGT_CMD_SET_FLASH_KEYS   (0x92U)
   8      =1  #define TGT_CMD_SET_ADDR         (0x93U)
   9      =1  #define TGT_CMD_ERASE_PAGE       (0x94U)
  10      =1  #define TGT_CMD_WRITE_FLASH      (0x95U)
  11      =1  #define TGT_CMD_GET_PAGE_CRC     (0x96U)
  12      =1  #define TGT_CMD_WRITE_SIGNATURE  (0x97U)
  13      =1  #define TGT_CMD_SW_RESET         (0x98U)
  14      =1  #define TGT_CMD_SW_INFO          (0x9FU)
  15      =1  
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 25  

  16      =1  // EEPROM
  17      =1  #define  EEPROM_CAPACITY                        (1048576)       // EEPROM Capacity (bytes)
  18      =1  #define  EEPROM_PAGE_SIZE                       (256)           // EEPROM Page Size (bytes)
  19      =1  #define  EEPROM_SECTOR_SIZE                     (4096)          // EEPROM Sector Size (bytes)
  20      =1  #define  EEPROM_BLOCK_SIZE                      (65536)         // EEPROM Block Size (bytes)
  21      =1  #define  EEPROM_CMD_WREN                        (0x06U)         // write enable
  22      =1  #define  EEPROM_CMD_RDDT                        (0x03U)         // read data
  23      =1  #define  EEPROM_CMD_WRDI                        (0x04U)         // write disable
  24      =1  #define  EEPROM_CMD_RDSR                        (0x05)          // status register read
  25      =1  #define  EEPROM_CMD_FAST_READ           (0x0BU)         // +AD1,AD2,AD3+Dummy fast read data
  26      =1  #define  EEPROM_CMD_REMS                        (0x90U)         // +Dummy,Dummy,ADD read electronic manufacturer & device ID)
  27      =1  #define  EEPROM_CMD_SE                          (0x20U)         // +AD1,AD2,AD3 sector erase (4KB) 0~255 sector
  28      =1  #define  EEPROM_CMD_PP                          (0x02U)         // +AD1,AD2,AD3 page program (256 byte)
  29      =1  #define  EEPROM_STATUS_WIP                      (0x01U)         // write in progress bit
  30      =1  
  31      =1  // Reserved space first byte
  32      =1  #define RESERVED_SPACE_ADDR                     (31*1024)       // 0x7C00U
  33      =1  
  34      =1  void Flash_Wait(void);
  35      =1  void Flash_DataSet(U8 flash_data);
  36      =1  void Flash_Slave_Select(void);
  37      =1  void Flash_Slave_Command(U8 flash_cmd);
  38      =1  void Update_Flash_Proc(U8 Mode, U8 Buf);
  39      =1  void Flash_EraseSector( U32 Addr );
  40      =1  void Spi_Init (void);
  41      =1  U8      Check_Flash_ID( void );
  42      =1  U8 spi_master_read(U8 addr);
  43      =1  void spi_master_write(U8 addr, U8 dat);
  44      =1  void    Flash_Write( U32 Addr,U8 *Data, U16 Len );
  45      =1  U8      Flash_Read( U32 Addr,U8 *Data, U16 Len );
  46      =1  #endif
  47      =1  
  48      =1  
   7          #include "drv_timer.h"
   1      =1  #ifndef DRV_TIMER_H
   2      =1  #define DRV_TIMER_H
   3      =1  
   4      =1  /* ----- Global Define -------------------------------*/
   5      =1  
   6      =1  #define TID_10ms_TIMER                          0x01U
   7      =1  #define TID_50ms_TIMER                          0x02U
   8      =1  #define TID_100ms_TIMER                         0x03U
   9      =1  #define TID_200ms_TIMER                         0x04U
  10      =1  #define TID_500ms_TIMER                         0x05U
  11      =1  #define TID_1000ms_TIMER                        0x06U
  12      =1  #define TID_2000ms_TIMER                        0x07U
  13      =1  #define TID_DIAG_ECU_RESET                      0x08U
  14      =1  #define TID_FIRME_UPDATE                        0x09U
  15      =1  #define TID_SENSOR_RESET                        0x0AU
  16      =1  #define TID_CHECKSTATUS_LOOP            0x0BU
  17      =1  #define TID_ADC_CHANGE_TIMER            0x0CU
  18      =1  #define TID_I2C_BUSY_CHECK                      0x0DU
  19      =1  #define TID_COUNT                                       0x0EU
  20      =1  
  21      =1  /*----------TIMER DELAY-------------*/
  22      =1  #define DT_10ms_TIMER                            10U
  23      =1  #define DT_50ms_TIMER                            50U
  24      =1  #define DT_100ms_TIMER                          100U
  25      =1  #define DT_200ms_TIMER                  200U
  26      =1  #define DT_500ms_TIMER                  500U
  27      =1  #define DT_1000ms_TIMER            1000U
  28      =1  #define DT_2000ms_TIMER                300U
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 26  

  29      =1  #define DT_DIAG_ECU_RESET                   500U
  30      =1  #define DT_FIRME_UPDATE                          30U
  31      =1  #define DT_SENSOR_RESET                         500U
  32      =1  #define DT_SENSOR_IDLE_PERIOD           300U
  33      =1  #define DT_CHECKSTATUS_LOOP                      30U
  34      =1  #define DT_ADC_CHANGE_TIMER                  10U
  35      =1  #define DT_I2C_COMM_CHECK                    10U
  36      =1  #define DT_I2C_BUSY_CHECK                        50U
  37      =1  /*----------------------------------------------------*/
  38      =1  typedef struct {
  39      =1          U8      Set;
  40      =1          U32 Delay_Time;
  41      =1          U32 Cur_Time;
  42      =1          U32 End_Time;
  43      =1  }tMsg_Time_s;
  44      =1  
  45      =1  typedef struct {
  46      =1          U32 Tick_1ms;
  47      =1          U32     Limit;
  48      =1          U8      Over_Set;
  49      =1  }tMsg_Global_Tick;
  50      =1  
  51      =1  /* ----- Function ------------------------------------*/
  52      =1  void Timer0_Init(void);
  53      =1  void Timer1_Init(void);
  54      =1  #if defined(TIMER2)
           =1 void Timer2_Init(void);
           =1 #endif
  57      =1  void Timer3_Init(void);
  58      =1  void Timer4_Init(void);
  59      =1  void Timer5_Init(void);
  60      =1  void TIMER1__Init (void);
  61      =1  void Wait_ms (U16 ms);
  62      =1  void Global_Timer_Init(void);
  63      =1  void Delay_Time_Set(U8 ID, U16 Delay_Time);
  64      =1  U8   Delay_Time_Get(U8 ID);
  65      =1  void Delay_Time_Expire(U8 ID);
  66      =1  U16 Get_Time(void);
  67      =1  /*----------------------------------------------------*/
  68      =1  
  69      =1  /* ----- Extern Function -----------------------------*/
  70      =1  extern SEG_XDATA tMsg_Global_Tick g_Global_Tick_Msg;
  71      =1  extern SEG_XDATA tMsg_Time_s    ga_tCAN_Time_Msg[TID_COUNT];
  72      =1  /*----------------------------------------------------*/
  73      =1  
  74      =1  /* ----- Global Value --------------------------------*/
  75      =1  /*----------------------------------------------------*/
  76      =1  
  77      =1  #endif
   8          
   9          /*--------------------------------------------------------------*/
  10          static SEG_XDATA volatile U8    gTemp   = 0x00U;
  11          
  12          void Spi_Init (void)
  13          {
  14   1              SEG_XDATA U8 SFRPAGE_save = SFRPAGE;
  15   1      
  16   1              SFRPAGE = ACTIVE_PAGE;
  17   1      
  18   1              SPI0CFG   = 0x40U;                                      // Enable the SPI as a Master
  19   1      //      SPI0CFG   = 0x50U;                                      // Enable the SPI as a Master
  20   1      //      SPI0CFG   = 0x70U;                                      // Enable the SPI as a Master
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 27  

  21   1                                                                                      // CKPHA = '0', CKPOL = '0'
  22   1      
  23   1              SPI0CN    = 0x0DU;                                      // 4-wire, single master mode
  24   1                                                                                      // SPI0 enable
  25   1      
  26   1              SPI0CKR   = 0x00U;                                      //fSCK = SYSCLK/(2x(SPI0CKR+1)) 0x0BU = 1Mbps, 0x17 = 500Kbps
  27   1      
  28   1              SFRPAGE = SFRPAGE_save;
  29   1      }
  30          
  31          U8 spi_master_read(U8 addr)
  32          {
  33   1              SEG_XDATA U8 dat; 
  34   1              SEG_XDATA U8 rd_addr = 0x00U;
  35   1      
  36   1              rd_addr = (U8)(addr & 0x3FU);
  37   1              rd_addr |= 0x80U;
  38   1      
  39   1              NSSMD0   = 0; // Activate Slave Select
  40   1      
  41   1              Flash_DataSet( rd_addr );
  42   1              Flash_Wait();
  43   1              SPIF     = 0U;
  44   1              SPI0DAT  = 0U; // Dummy write to output serial clock
  45   1              Flash_Wait();
  46   1              dat = (U8)SPI0DAT; // Read data
  47   1      
  48   1              SPIF    = 0U;
  49   1              NSSMD0  = 1U; // Deactivate Slave Select
  50   1      
  51   1              return dat;
  52   1      }
  53          
  54          void spi_master_write(U8 addr, U8 dat)
  55          {
  56   1              SEG_XDATA U8    wr_addr = 0x00U;
  57   1              
  58   1              wr_addr = (U8)(addr & 0x3FU);
  59   1      
  60   1              NSSMD0   = 0U; // Activate Slave Select
  61   1      
  62   1              Flash_DataSet( wr_addr );
  63   1              Flash_Wait();
  64   1              Flash_DataSet( dat );
  65   1              Flash_Wait();
  66   1      
  67   1              SPIF    = 0U;
  68   1              NSSMD0  = 1U; // Deactivate Slave Select
  69   1      }
  70          
  71          void Flash_Wait( void )
  72          {
  73   1              static SEG_XDATA volatile U8    reg_4val = 0x00U;
  74   1      
  75   1              while( 1 ){
  76   2                      reg_4val = (U8)SPIF;
  77   2                      if( reg_4val != 0x00U ){
  78   3                              break;
  79   3                      }
  80   2              }
  81   1      }
  82          
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 28  

  83          void Flash_DataSet( U8 flash_data )
  84          {
  85   1              SPIF     = 0U;
  86   1              SPI0DAT  = flash_data;
  87   1      }
  88          
  89          void Flash_Slave_Select( void )
  90          {
  91   1              SPIF    = 0U;
  92   1              NSSMD0  = 1U;
  93   1      }
  94          
  95          void Flash_Slave_Command( U8 flash_cmd )
  96          {
  97   1              NSSMD0   = 0U;                       // Activate Slave Select
  98   1              SPI0DAT  = flash_cmd;                                   // command
  99   1      }
 100          
 101          U8      Check_Flash_ID( void )
 102          {
 103   1              SEG_XDATA U8 rtn = 1U,i = 0U;
 104   1      
 105   1              // Send the command
 106   1              Flash_Slave_Command( (U8)EEPROM_CMD_REMS );
 107   1              Flash_Wait();
 108   1              
 109   1              Flash_DataSet( 0x00U );
 110   1              Flash_Wait();
 111   1      
 112   1              Flash_DataSet( 0x00U );
 113   1              Flash_Wait();
 114   1      
 115   1              Flash_DataSet( 0x00U );
 116   1              Flash_Wait();
 117   1      
 118   1              Flash_DataSet( 0x00U );
 119   1              Flash_Wait();
 120   1      
 121   1              SPIF     = 0U;
 122   1              gTemp = (U8)SPI0DAT;                            // Read data before restoring SFR page
 123   1      
 124   1              if( gTemp != 0xC2U ){
 125   2      
 126   2                      SPIF     = 0U;
 127   2                      SPI0DAT  = 0U;                       // Dummy write to output serial clock
 128   2                      Flash_Wait();
 129   2                      // Send the command
 130   2                      Flash_Slave_Command( (U8)EEPROM_CMD_REMS );
 131   2                      Flash_Wait();
 132   2              
 133   2                      Flash_DataSet( 0x00U );
 134   2                      Flash_Wait();
 135   2      
 136   2                      Flash_DataSet( 0x00U );
 137   2                      Flash_Wait();
 138   2      
 139   2                      Flash_DataSet( 0x00U );
 140   2                      Flash_Wait();
 141   2      
 142   2                      SPIF     = 0U;
 143   2                      SPI0DAT  = 0U;                       // Dummy write to output serial clock
 144   2                      Flash_Wait();
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 29  

 145   2              gTemp = (U8)SPI0DAT;                            // Read data before restoring SFR page
 146   2      
 147   2              if( gTemp != 0xEFU ){
 148   3                      rtn = 0U;
 149   3      
 150   3                      }else{
 151   3                              // Read the value returned
 152   3                              SPIF     = 0U;
 153   3                              SPI0DAT  = 0U;                       // Dummy write to output serial clock
 154   3                              Flash_Wait();
 155   3      
 156   3                              Flash_Slave_Select();
 157   3                              gTemp = (U8)SPI0DAT;                    // Read data before restoring SFR page
 158   3      
 159   3                              if( (gTemp != 0x11U) ){//2Mbit
 160   4                                      rtn = 0U;
 161   4                              }
 162   3                      }
 163   2                      NSSMD0   = 1U;                       // Deactivate Slave Select
 164   2              }
 165   1              else
 166   1              {
 167   2                      // Read the value returned
 168   2                      SPI0DAT  = 0U;                       // Dummy write to output serial clock
 169   2                      Flash_Wait();
 170   2      
 171   2                      Flash_Slave_Select();
 172   2                      gTemp = (U8)SPI0DAT;                    // Read data before restoring SFR page
 173   2      
 174   2                      if( (gTemp != 0x11U) ){//2Mbit
 175   3                              rtn = 0U;
 176   3                      }
 177   2                      else
 178   2                      {
 179   3                              Flash_Slave_Command( (U8)EEPROM_CMD_RDSR );
 180   3                              Flash_Wait();
 181   3                              
 182   3                              Flash_DataSet( 0x00U );
 183   3                              Flash_Wait();
 184   3                      
 185   3                              SPIF     = 0U;
 186   3                              gTemp = (U8)SPI0DAT;                    // Read data before restoring SFR page
 187   3      
 188   3                              NSSMD0   = 1U;                       // Deactivate Slave Select
 189   3                      }
 190   2              }
 191   1              
 192   1              return rtn;
 193   1      }
 194          
 195          void    Flash_Write( U32 Addr,U8 *Data, U16 Len )
 196          {
 197   1              SEG_XDATA U16 lp;
 198   1      
 199   1                      // Send the command
 200   1                      Flash_Slave_Command( (U8)EEPROM_CMD_WREN );
 201   1                      Flash_Wait();
 202   1      
 203   1                      Flash_Slave_Select();
 204   1              
 205   1                      Wait_ms(10U);
 206   1      
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 30  

 207   1                      Flash_Slave_Command( (U8)EEPROM_CMD_PP );
 208   1                      Flash_Wait();
 209   1      
 210   1                      Flash_DataSet( ((U8)(Addr>>16U) & 0xFFU) );
 211   1                      Flash_Wait();
 212   1      
 213   1                      Flash_DataSet( ((U8)(Addr>>8U) & 0xFFU) );
 214   1                      Flash_Wait();
 215   1      
 216   1                      Flash_DataSet( (U8)(Addr & 0xFFU) );
 217   1                      Flash_Wait();
 218   1      
 219   1                      SPIF     = 0U;
 220   1      
 221   1                      // Read the value returned
 222   1                      for( lp = 0x0000U; lp < Len; lp++ )
 223   1                      {
 224   2                              Flash_DataSet( Data[lp] );
 225   2                              Flash_Wait();
 226   2      
 227   2                              SPIF     = 0U;
 228   2                      }
 229   1              
 230   1                      NSSMD0   = 1U;          // Deactivate Slave Select
 231   1              
 232   1                      Wait_ms(10U);
 233   1      
 234   1                      NSSMD0   = 0U;
 235   1      
 236   1                      while( 1 )
 237   1                      {
 238   2                              Flash_DataSet( (U8)EEPROM_CMD_RDSR );
 239   2                              Flash_Wait();
 240   2      
 241   2                              SPIF     = 0U;
 242   2                              SPI0DAT  = 0U;                    // Dummy write to output serial clock
 243   2                              Flash_Wait();
 244   2                              gTemp = (U8)SPI0DAT;                 // Read data before restoring SFR page
 245   2      
 246   2                              if( (gTemp & (U8)EEPROM_STATUS_WIP) == 0x00U ){ // write in progress bit
 247   3                                      break;
 248   3                              }
 249   2                      }
 250   1              
 251   1                      NSSMD0   = 1U;                                          // Deactivate Slave Select
 252   1              
 253   1                      Wait_ms(10U);
 254   1      
 255   1                      Flash_Slave_Command( (U8)EEPROM_CMD_WRDI );
 256   1                      Flash_Wait();
 257   1      
 258   1                      Flash_Slave_Select();
 259   1      
 260   1      }
 261          
 262          
 263          U8      Flash_Read( U32 Addr,U8 *Data, U16 Len )
 264          {
 265   1              SEG_XDATA U8 rtn = 1U;
 266   1              SEG_XDATA U16 i = 0U;
 267   1      
 268   1              // Send the command
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 31  

 269   1              Flash_Slave_Command( (U8)EEPROM_CMD_RDDT );
 270   1              Flash_Wait();
 271   1      
 272   1              Flash_DataSet( ((U8)(Addr>>16U) & 0xFFU) );
 273   1              Flash_Wait();
 274   1      
 275   1              Flash_DataSet( ((U8)(Addr>>8U) & 0xFFU) );
 276   1              Flash_Wait();
 277   1      
 278   1              Flash_DataSet( (U8)(Addr & 0xFFU) );
 279   1              Flash_Wait();
 280   1      
 281   1              for( i = 0; i < Len; i++)
 282   1              {
 283   2                      Flash_DataSet( 0x00U );
 284   2                      Flash_Wait();
 285   2      
 286   2                      SPIF     = (U8)0;
 287   2                      *Data++ = (U8)SPI0DAT; 
 288   2              }
 289   1              NSSMD0   = 1U;                                          // Deactivate Slave Select
 290   1      
 291   1              Wait_ms(10U);
 292   1      
 293   1              Flash_Slave_Command( (U8)EEPROM_CMD_WRDI );
 294   1              Flash_Wait();
 295   1      
 296   1              Flash_Slave_Select();
 297   1              return rtn;
 298   1      }
 299          
 300          void    Flash_EraseSector( U32 Addr )
 301          {
 302   1                      // Send the command
 303   1                      Flash_Slave_Command( (U8)EEPROM_CMD_WREN );
 304   1                      Flash_Wait();
 305   1      
 306   1                      Flash_Slave_Select();
 307   1              
 308   1                      Wait_ms(10U);
 309   1      
 310   1                      Flash_Slave_Command( (U8)EEPROM_CMD_SE );
 311   1                      Flash_Wait();
 312   1      
 313   1                      Flash_DataSet( ((U8)(Addr>>16U)&0xFFU) );
 314   1                      Flash_Wait();
 315   1      
 316   1                      Flash_DataSet( ((U8)(Addr>>8U)&0xFFU) );
 317   1                      Flash_Wait();
 318   1      
 319   1                      Flash_DataSet( (U8)(Addr&0xFFU) );
 320   1                      Flash_Wait();
 321   1      
 322   1                      Flash_Slave_Select();
 323   1      
 324   1                      Wait_ms(10U);
 325   1      
 326   1                      NSSMD0   = 0U;
 327   1      
 328   1                      while( 1 )
 329   1                      {
 330   2                              SPI0DAT  = EEPROM_CMD_RDSR;                     // status register read
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 32  

 331   2                              Flash_Wait();
 332   2      
 333   2                              SPIF     = 0U;
 334   2                              SPI0DAT  = 0U;                       // Dummy write to output serial clock
 335   2                              Flash_Wait();
 336   2                              gTemp = (U8)SPI0DAT;                    // Read data before restoring SFR page
 337   2      
 338   2                              if( (gTemp & (U8)EEPROM_STATUS_WIP) == 0x00U ){ // write in progress bit
 339   3                                      break;
 340   3                              }
 341   2                              Wait_ms(10U);
 342   2                      }
 343   1              
 344   1                      NSSMD0   = 1U;                                          // Deactivate Slave Select
 345   1              
 346   1                      Wait_ms(10U);
 347   1      
 348   1                      Flash_Slave_Command( (U8)EEPROM_CMD_WRDI );
 349   1                      Flash_Wait();
 350   1                      
 351   1                      Flash_Slave_Select();
 352   1      }
 353          
 354          /* end of file */
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 33  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Spi_Init (BEGIN)
                                           ; SOURCE LINE # 12
                                           ; SOURCE LINE # 13
                                           ; SOURCE LINE # 14
;---- Variable 'SFRPAGE_save' assigned to Register 'R7' ----
0000 AFA7              MOV     R7,SFRPAGE
                                           ; SOURCE LINE # 16
0002 E4                CLR     A
0003 F5A7              MOV     SFRPAGE,A
                                           ; SOURCE LINE # 18
0005 75A140            MOV     SPI0CFG,#040H
                                           ; SOURCE LINE # 23
0008 75F80D            MOV     SPI0CN,#0DH
                                           ; SOURCE LINE # 26
000B F5A2              MOV     SPI0CKR,A
                                           ; SOURCE LINE # 28
000D 8FA7              MOV     SFRPAGE,R7
                                           ; SOURCE LINE # 29
000F 22                RET     
             ; FUNCTION Spi_Init (END)

             ; FUNCTION _spi_master_read (BEGIN)
                                           ; SOURCE LINE # 31
;---- Variable 'addr' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 32
                                           ; SOURCE LINE # 34
;---- Variable 'rd_addr' assigned to Register 'R6' ----
0000 E4                CLR     A
0001 FE                MOV     R6,A
                                           ; SOURCE LINE # 36
0002 EF                MOV     A,R7
0003 543F              ANL     A,#03FH
0005 FE                MOV     R6,A
                                           ; SOURCE LINE # 37
0006 4480              ORL     A,#080H
0008 FE                MOV     R6,A
                                           ; SOURCE LINE # 39
0009 C2FA              CLR     NSSMD0
                                           ; SOURCE LINE # 41
000B FF                MOV     R7,A
000C 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 42
000F 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 43
0012 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 44
0014 E4                CLR     A
0015 F5A3              MOV     SPI0DAT,A
                                           ; SOURCE LINE # 45
0017 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 46
;---- Variable 'dat' assigned to Register 'R7' ----
001A AFA3              MOV     R7,SPI0DAT
                                           ; SOURCE LINE # 48
001C C2FF              CLR     SPIF
                                           ; SOURCE LINE # 49
001E D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 51
                                           ; SOURCE LINE # 52
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 34  

0020 22                RET     
             ; FUNCTION _spi_master_read (END)

             ; FUNCTION _spi_master_write (BEGIN)
                                           ; SOURCE LINE # 54
0000 900000      R     MOV     DPTR,#dat
0003 ED                MOV     A,R5
0004 F0                MOVX    @DPTR,A
;---- Variable 'addr' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 55
                                           ; SOURCE LINE # 56
;---- Variable 'wr_addr' assigned to Register 'R6' ----
0005 E4                CLR     A
0006 FE                MOV     R6,A
                                           ; SOURCE LINE # 58
0007 EF                MOV     A,R7
0008 543F              ANL     A,#03FH
000A FE                MOV     R6,A
                                           ; SOURCE LINE # 60
000B C2FA              CLR     NSSMD0
                                           ; SOURCE LINE # 62
000D FF                MOV     R7,A
000E 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 63
0011 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 64
0014 900000      R     MOV     DPTR,#dat
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 65
001C 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 67
001F C2FF              CLR     SPIF
                                           ; SOURCE LINE # 68
0021 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 69
0023 22                RET     
             ; FUNCTION _spi_master_write (END)

             ; FUNCTION Flash_Wait (BEGIN)
                                           ; SOURCE LINE # 71
                                           ; SOURCE LINE # 72
0000         ?C0004:
                                           ; SOURCE LINE # 75
                                           ; SOURCE LINE # 76
0000 A2FF              MOV     C,SPIF
0002 E4                CLR     A
0003 33                RLC     A
0004 900000      R     MOV     DPTR,#reg_4val
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 77
0008 E0                MOVX    A,@DPTR
0009 60F5              JZ      ?C0004
                                           ; SOURCE LINE # 78
000B 22                RET     
                                           ; SOURCE LINE # 79
                                           ; SOURCE LINE # 80
000C 80F2              SJMP    ?C0004
                                           ; SOURCE LINE # 81
000E         ?C0007:
000E 22                RET     
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 35  

             ; FUNCTION Flash_Wait (END)

             ; FUNCTION _Flash_DataSet (BEGIN)
                                           ; SOURCE LINE # 83
;---- Variable 'flash_data' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 84
                                           ; SOURCE LINE # 85
0000 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 86
0002 8FA3              MOV     SPI0DAT,R7
                                           ; SOURCE LINE # 87
0004 22                RET     
             ; FUNCTION _Flash_DataSet (END)

             ; FUNCTION Flash_Slave_Select (BEGIN)
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 90
                                           ; SOURCE LINE # 91
0000 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 92
0002 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 93
0004 22                RET     
             ; FUNCTION Flash_Slave_Select (END)

             ; FUNCTION _Flash_Slave_Command (BEGIN)
                                           ; SOURCE LINE # 95
;---- Variable 'flash_cmd' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 96
                                           ; SOURCE LINE # 97
0000 C2FA              CLR     NSSMD0
                                           ; SOURCE LINE # 98
0002 8FA3              MOV     SPI0DAT,R7
                                           ; SOURCE LINE # 99
0004 22                RET     
             ; FUNCTION _Flash_Slave_Command (END)

             ; FUNCTION Check_Flash_ID (BEGIN)
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 103
;---- Variable 'rtn' assigned to Register 'R6' ----
0000 7E01              MOV     R6,#01H
0002 E4                CLR     A
0003 900000      R     MOV     DPTR,#i
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 106
0007 7F90              MOV     R7,#090H
0009 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 107
000C 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 109
000F E4                CLR     A
0010 FF                MOV     R7,A
0011 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 110
0014 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 112
0017 E4                CLR     A
0018 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 113
001B 120000      R     LCALL   Flash_Wait
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 36  

                                           ; SOURCE LINE # 115
001E E4                CLR     A
001F 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 116
0022 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 118
0025 E4                CLR     A
0026 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 119
0029 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 121
002C C2FF              CLR     SPIF
                                           ; SOURCE LINE # 122
002E 900000      R     MOV     DPTR,#gTemp
0031 E5A3              MOV     A,SPI0DAT
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 124
0034 E0                MOVX    A,@DPTR
0035 64C2              XRL     A,#0C2H
0037 6059              JZ      ?C0011
                                           ; SOURCE LINE # 126
0039 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 127
003B E4                CLR     A
003C F5A3              MOV     SPI0DAT,A
                                           ; SOURCE LINE # 128
003E 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 130
0041 7F90              MOV     R7,#090H
0043 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 131
0046 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 133
0049 E4                CLR     A
004A FF                MOV     R7,A
004B 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 134
004E 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 136
0051 E4                CLR     A
0052 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 137
0055 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 139
0058 E4                CLR     A
0059 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 140
005C 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 142
005F C2FF              CLR     SPIF
                                           ; SOURCE LINE # 143
0061 E4                CLR     A
0062 F5A3              MOV     SPI0DAT,A
                                           ; SOURCE LINE # 144
0064 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 145
0067 900000      R     MOV     DPTR,#gTemp
006A E5A3              MOV     A,SPI0DAT
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 147
006D E0                MOVX    A,@DPTR
006E 64EF              XRL     A,#0EFH
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 37  

0070 6004              JZ      ?C0012
                                           ; SOURCE LINE # 148
0072 E4                CLR     A
0073 1E                DEC     R6
                                           ; SOURCE LINE # 150
0074 8018              SJMP    ?C0013
0076         ?C0012:
                                           ; SOURCE LINE # 152
0076 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 153
0078 E4                CLR     A
0079 F5A3              MOV     SPI0DAT,A
                                           ; SOURCE LINE # 154
007B 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 156
007E 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 157
0081 900000      R     MOV     DPTR,#gTemp
0084 E5A3              MOV     A,SPI0DAT
0086 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 159
0087 E0                MOVX    A,@DPTR
0088 6411              XRL     A,#011H
008A 6002              JZ      ?C0013
                                           ; SOURCE LINE # 160
008C E4                CLR     A
008D FE                MOV     R6,A
                                           ; SOURCE LINE # 161
                                           ; SOURCE LINE # 162
008E         ?C0013:
                                           ; SOURCE LINE # 163
008E D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 164
0090 8032              SJMP    ?C0015
0092         ?C0011:
                                           ; SOURCE LINE # 166
                                           ; SOURCE LINE # 168
0092 E4                CLR     A
0093 F5A3              MOV     SPI0DAT,A
                                           ; SOURCE LINE # 169
0095 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 171
0098 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 172
009B 900000      R     MOV     DPTR,#gTemp
009E E5A3              MOV     A,SPI0DAT
00A0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 174
00A1 E0                MOVX    A,@DPTR
00A2 6411              XRL     A,#011H
00A4 6004              JZ      ?C0016
                                           ; SOURCE LINE # 175
00A6 E4                CLR     A
00A7 FE                MOV     R6,A
                                           ; SOURCE LINE # 176
00A8 801A              SJMP    ?C0015
00AA         ?C0016:
                                           ; SOURCE LINE # 178
                                           ; SOURCE LINE # 179
00AA 7F05              MOV     R7,#05H
00AC 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 180
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 38  

00AF 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 182
00B2 E4                CLR     A
00B3 FF                MOV     R7,A
00B4 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 183
00B7 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 185
00BA C2FF              CLR     SPIF
                                           ; SOURCE LINE # 186
00BC 900000      R     MOV     DPTR,#gTemp
00BF E5A3              MOV     A,SPI0DAT
00C1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 188
00C2 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 189
                                           ; SOURCE LINE # 190
00C4         ?C0015:
                                           ; SOURCE LINE # 192
00C4 EE                MOV     A,R6
00C5 FF                MOV     R7,A
                                           ; SOURCE LINE # 193
00C6 22                RET     
             ; FUNCTION Check_Flash_ID (END)

             ; FUNCTION _Flash_Write (BEGIN)
                                           ; SOURCE LINE # 195
0000 900000      R     MOV     DPTR,#Addr
0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#Data
0009 EB                MOV     A,R3
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C EA                MOV     A,R2
000D F0                MOVX    @DPTR,A
000E A3                INC     DPTR
000F E9                MOV     A,R1
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 196
                                           ; SOURCE LINE # 200
0011 7F06              MOV     R7,#06H
0013 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 201
0016 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 203
0019 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 205
001C 7F0A              MOV     R7,#0AH
001E 7E00              MOV     R6,#00H
0020 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 207
0023 7F02              MOV     R7,#02H
0025 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 208
0028 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 210
002B 900000      R     MOV     DPTR,#Addr
002E E0                MOVX    A,@DPTR
002F FC                MOV     R4,A
0030 A3                INC     DPTR
0031 E0                MOVX    A,@DPTR
0032 FD                MOV     R5,A
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 39  

0033 A3                INC     DPTR
0034 E0                MOVX    A,@DPTR
0035 FE                MOV     R6,A
0036 A3                INC     DPTR
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 7810              MOV     R0,#010H
003B 120000      E     LCALL   ?C?ULSHR
003E EF                MOV     A,R7
003F 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 211
0042 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 213
0045 900000      R     MOV     DPTR,#Addr
0048 E0                MOVX    A,@DPTR
0049 FC                MOV     R4,A
004A A3                INC     DPTR
004B E0                MOVX    A,@DPTR
004C FD                MOV     R5,A
004D A3                INC     DPTR
004E E0                MOVX    A,@DPTR
004F FE                MOV     R6,A
0050 A3                INC     DPTR
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
0053 7808              MOV     R0,#08H
0055 120000      E     LCALL   ?C?ULSHR
0058 EF                MOV     A,R7
0059 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 214
005C 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 216
005F 900000      R     MOV     DPTR,#Addr
0062 E0                MOVX    A,@DPTR
0063 FC                MOV     R4,A
0064 A3                INC     DPTR
0065 E0                MOVX    A,@DPTR
0066 FD                MOV     R5,A
0067 A3                INC     DPTR
0068 E0                MOVX    A,@DPTR
0069 FE                MOV     R6,A
006A A3                INC     DPTR
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
006D E4                CLR     A
006E 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 217
0071 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 219
0074 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 222
;---- Variable 'lp' assigned to Register 'R4/R5' ----
0076 E4                CLR     A
0077 FD                MOV     R5,A
0078 FC                MOV     R4,A
0079         ?C0019:
0079 D3                SETB    C
007A 900000      R     MOV     DPTR,#Len+01H
007D E0                MOVX    A,@DPTR
007E 9D                SUBB    A,R5
007F 900000      R     MOV     DPTR,#Len
0082 E0                MOVX    A,@DPTR
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 40  

0083 9C                SUBB    A,R4
0084 4022              JC      ?C0020
                                           ; SOURCE LINE # 223
                                           ; SOURCE LINE # 224
0086 900000      R     MOV     DPTR,#Data
0089 E0                MOVX    A,@DPTR
008A FB                MOV     R3,A
008B A3                INC     DPTR
008C E0                MOVX    A,@DPTR
008D FA                MOV     R2,A
008E A3                INC     DPTR
008F E0                MOVX    A,@DPTR
0090 F9                MOV     R1,A
0091 8D82              MOV     DPL,R5
0093 8C83              MOV     DPH,R4
0095 120000      E     LCALL   ?C?CLDOPTR
0098 FF                MOV     R7,A
0099 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 225
009C 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 227
009F C2FF              CLR     SPIF
                                           ; SOURCE LINE # 228
00A1 0D                INC     R5
00A2 BD0001            CJNE    R5,#00H,?C0034
00A5 0C                INC     R4
00A6         ?C0034:
00A6 80D1              SJMP    ?C0019
00A8         ?C0020:
                                           ; SOURCE LINE # 230
00A8 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 232
00AA 7F0A              MOV     R7,#0AH
00AC 7E00              MOV     R6,#00H
00AE 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 234
00B1 C2FA              CLR     NSSMD0
00B3         ?C0022:
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
                                           ; SOURCE LINE # 238
00B3 7F05              MOV     R7,#05H
00B5 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 239
00B8 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 241
00BB C2FF              CLR     SPIF
                                           ; SOURCE LINE # 242
00BD E4                CLR     A
00BE F5A3              MOV     SPI0DAT,A
                                           ; SOURCE LINE # 243
00C0 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 244
00C3 900000      R     MOV     DPTR,#gTemp
00C6 E5A3              MOV     A,SPI0DAT
00C8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 246
00C9 E0                MOVX    A,@DPTR
00CA 5401              ANL     A,#01H
00CC 70E5              JNZ     ?C0022
                                           ; SOURCE LINE # 247
00CE 8002              SJMP    ?C0023
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 41  

                                           ; SOURCE LINE # 248
                                           ; SOURCE LINE # 249
00D0 80E1              SJMP    ?C0022
00D2         ?C0023:
                                           ; SOURCE LINE # 251
00D2 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 253
00D4 7F0A              MOV     R7,#0AH
00D6 7E00              MOV     R6,#00H
00D8 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 255
00DB 7F04              MOV     R7,#04H
00DD 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 256
00E0 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 258
00E3 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 260
00E6 22                RET     
             ; FUNCTION _Flash_Write (END)

             ; FUNCTION _Flash_Read (BEGIN)
                                           ; SOURCE LINE # 263
0000 900000      R     MOV     DPTR,#Addr
0003 120000      E     LCALL   ?C?LSTXDATA
0006 900000      R     MOV     DPTR,#Data
0009 EB                MOV     A,R3
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C EA                MOV     A,R2
000D F0                MOVX    @DPTR,A
000E A3                INC     DPTR
000F E9                MOV     A,R1
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 265
0011 900000      R     MOV     DPTR,#rtn
0014 7401              MOV     A,#01H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 266
0017 E4                CLR     A
0018 A3                INC     DPTR
0019 F0                MOVX    @DPTR,A
001A A3                INC     DPTR
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 269
001C 7F03              MOV     R7,#03H
001E 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 270
0021 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 272
0024 900000      R     MOV     DPTR,#Addr
0027 E0                MOVX    A,@DPTR
0028 FC                MOV     R4,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FD                MOV     R5,A
002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E FE                MOV     R6,A
002F A3                INC     DPTR
0030 E0                MOVX    A,@DPTR
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 42  

0031 FF                MOV     R7,A
0032 7810              MOV     R0,#010H
0034 120000      E     LCALL   ?C?ULSHR
0037 EF                MOV     A,R7
0038 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 273
003B 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 275
003E 900000      R     MOV     DPTR,#Addr
0041 E0                MOVX    A,@DPTR
0042 FC                MOV     R4,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FD                MOV     R5,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 FE                MOV     R6,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C 7808              MOV     R0,#08H
004E 120000      E     LCALL   ?C?ULSHR
0051 EF                MOV     A,R7
0052 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 276
0055 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 278
0058 900000      R     MOV     DPTR,#Addr
005B E0                MOVX    A,@DPTR
005C FC                MOV     R4,A
005D A3                INC     DPTR
005E E0                MOVX    A,@DPTR
005F FD                MOV     R5,A
0060 A3                INC     DPTR
0061 E0                MOVX    A,@DPTR
0062 FE                MOV     R6,A
0063 A3                INC     DPTR
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
0066 E4                CLR     A
0067 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 279
006A 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 281
006D E4                CLR     A
006E 900000      R     MOV     DPTR,#i
0071 F0                MOVX    @DPTR,A
0072 A3                INC     DPTR
0073 F0                MOVX    @DPTR,A
0074         ?C0026:
0074 900000      R     MOV     DPTR,#Len
0077 E0                MOVX    A,@DPTR
0078 FE                MOV     R6,A
0079 A3                INC     DPTR
007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C C3                CLR     C
007D 900000      R     MOV     DPTR,#i+01H
0080 E0                MOVX    A,@DPTR
0081 9F                SUBB    A,R7
0082 900000      R     MOV     DPTR,#i
0085 E0                MOVX    A,@DPTR
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 43  

0086 9E                SUBB    A,R6
0087 502F              JNC     ?C0027
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 283
0089 E4                CLR     A
008A FF                MOV     R7,A
008B 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 284
008E 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 286
0091 C2FF              CLR     SPIF
                                           ; SOURCE LINE # 287
0093 900000      R     MOV     DPTR,#Data
0096 E0                MOVX    A,@DPTR
0097 FB                MOV     R3,A
0098 A3                INC     DPTR
0099 E4                CLR     A
009A 75F001            MOV     B,#01H
009D 120000      E     LCALL   ?C?ILDIX
00A0 A9F0              MOV     R1,B
00A2 FA                MOV     R2,A
00A3 E5A3              MOV     A,SPI0DAT
00A5 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 288
00A8 900000      R     MOV     DPTR,#i+01H
00AB E0                MOVX    A,@DPTR
00AC 04                INC     A
00AD F0                MOVX    @DPTR,A
00AE 7006              JNZ     ?C0035
00B0 900000      R     MOV     DPTR,#i
00B3 E0                MOVX    A,@DPTR
00B4 04                INC     A
00B5 F0                MOVX    @DPTR,A
00B6         ?C0035:
00B6 80BC              SJMP    ?C0026
00B8         ?C0027:
                                           ; SOURCE LINE # 289
00B8 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 291
00BA 7F0A              MOV     R7,#0AH
00BC 7E00              MOV     R6,#00H
00BE 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 293
00C1 7F04              MOV     R7,#04H
00C3 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 294
00C6 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 296
00C9 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 297
00CC 900000      R     MOV     DPTR,#rtn
00CF E0                MOVX    A,@DPTR
00D0 FF                MOV     R7,A
                                           ; SOURCE LINE # 298
00D1 22                RET     
             ; FUNCTION _Flash_Read (END)

             ; FUNCTION _Flash_EraseSector (BEGIN)
                                           ; SOURCE LINE # 300
0000 900000      R     MOV     DPTR,#Addr
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 301
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 44  

                                           ; SOURCE LINE # 303
0006 7F06              MOV     R7,#06H
0008 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 304
000B 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 306
000E 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 308
0011 7F0A              MOV     R7,#0AH
0013 7E00              MOV     R6,#00H
0015 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 310
0018 7F20              MOV     R7,#020H
001A 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 311
001D 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 313
0020 900000      R     MOV     DPTR,#Addr
0023 E0                MOVX    A,@DPTR
0024 FC                MOV     R4,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 FD                MOV     R5,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FE                MOV     R6,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 7810              MOV     R0,#010H
0030 120000      E     LCALL   ?C?ULSHR
0033 EF                MOV     A,R7
0034 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 314
0037 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 316
003A 900000      R     MOV     DPTR,#Addr
003D E0                MOVX    A,@DPTR
003E FC                MOV     R4,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FD                MOV     R5,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 FE                MOV     R6,A
0045 A3                INC     DPTR
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 7808              MOV     R0,#08H
004A 120000      E     LCALL   ?C?ULSHR
004D EF                MOV     A,R7
004E 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 317
0051 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 319
0054 900000      R     MOV     DPTR,#Addr
0057 E0                MOVX    A,@DPTR
0058 FC                MOV     R4,A
0059 A3                INC     DPTR
005A E0                MOVX    A,@DPTR
005B FD                MOV     R5,A
005C A3                INC     DPTR
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 45  

005D E0                MOVX    A,@DPTR
005E FE                MOV     R6,A
005F A3                INC     DPTR
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 E4                CLR     A
0063 120000      R     LCALL   _Flash_DataSet
                                           ; SOURCE LINE # 320
0066 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 322
0069 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 324
006C 7F0A              MOV     R7,#0AH
006E 7E00              MOV     R6,#00H
0070 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 326
0073 C2FA              CLR     NSSMD0
0075         ?C0030:
                                           ; SOURCE LINE # 328
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 330
0075 75A305            MOV     SPI0DAT,#05H
                                           ; SOURCE LINE # 331
0078 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 333
007B C2FF              CLR     SPIF
                                           ; SOURCE LINE # 334
007D E4                CLR     A
007E F5A3              MOV     SPI0DAT,A
                                           ; SOURCE LINE # 335
0080 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 336
0083 900000      R     MOV     DPTR,#gTemp
0086 E5A3              MOV     A,SPI0DAT
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 338
0089 E0                MOVX    A,@DPTR
008A 5401              ANL     A,#01H
008C 6009              JZ      ?C0031
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
008E 7F0A              MOV     R7,#0AH
0090 7E00              MOV     R6,#00H
0092 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 342
0095 80DE              SJMP    ?C0030
0097         ?C0031:
                                           ; SOURCE LINE # 344
0097 D2FA              SETB    NSSMD0
                                           ; SOURCE LINE # 346
0099 7F0A              MOV     R7,#0AH
009B 7E00              MOV     R6,#00H
009D 120000      E     LCALL   _Wait_ms
                                           ; SOURCE LINE # 348
00A0 7F04              MOV     R7,#04H
00A2 120000      R     LCALL   _Flash_Slave_Command
                                           ; SOURCE LINE # 349
00A5 120000      R     LCALL   Flash_Wait
                                           ; SOURCE LINE # 351
00A8 120000      R     LCALL   Flash_Slave_Select
                                           ; SOURCE LINE # 352
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 46  

00AB 22                RET     
             ; FUNCTION _Flash_EraseSector (END)

C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 47  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


U8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
U16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
U32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
S8 . . . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
S16. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
S32. . . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
UU16 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU16 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
UU32 . . . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
UU32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  U32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  S32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  UU16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  U8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  S8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
SPI0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
SPI0CKR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
SPI0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
SPI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
SPIF . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
NSSMD0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
Flash_Wait . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  reg_4val . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0000H  1
_Flash_DataSet . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flash_data . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
Flash_Slave_Select . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Flash_Slave_Command . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flash_cmd. . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
_Flash_EraseSector . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Addr . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
Spi_Init . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  SFRPAGE_save . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
Check_Flash_ID . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  rtn. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
_spi_master_read . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  dat. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
C51 COMPILER V9.59.0.0   DRV_SPI                                                           10/28/2023 03:58:59 PAGE 48  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  rd_addr. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
_spi_master_write. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  dat. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  wr_addr. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
_Flash_Write . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Addr . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  Data . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  Len. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0007H  2
  lp . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
_Flash_Read. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  Addr . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0000H  4
  Data . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0004H  3
  Len. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0007H  2
  rtn. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0009H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    000AH  2
tMsg_Time_s. . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  13
  Set. . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Delay_Time . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0001H  4
  Cur_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0005H  4
  End_Time . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0009H  4
tMsg_Global_Tick . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  Tick_1ms . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  Limit. . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
  Over_Set . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
_Wait_ms . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
gTemp. . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0001H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    927    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
