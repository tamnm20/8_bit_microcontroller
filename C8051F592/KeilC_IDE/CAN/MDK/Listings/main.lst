C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\User\main.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\main.ls
                    -t) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F580_CAN0_Transmit.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2008 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // This program transmits data to another CAN node using a configurable number
  10          // of message objects and datasize.  The message identifier is set based on the 
  11          // message object number.  The corresponding receive firmware is 
  12          // F580_CAN0_Receive.c.  The following two #defines should be set to the
  13          // same values in both the transmit and receive code:
  14          //
  15          // #define MESSAGE_OBJECTS          
  16          // #define MESSAGE_SIZE    
  17          //
  18          // #define TX_COMPLETE_MASK should also be set.  See definition for details
  19          //
  20          // The purpose of this example is to show how to initialize a message object
  21          // for transfer and how to handle certain error conditions.
  22          //
  23          // How To Test:
  24          //
  25          // 1) Verify the LED and switch pin jumpers are populated 
  26          //    (J19 for device A and J11 for device B).
  27          //
  28          // 2) Make sure the CAN jumpers in J17 (for A side) and J26 (for B side)
  29          //    are connected.
  30          //
  31          // 3) Download the code to a F580-TB (either device A or device B) that is
  32          //    connected as above to another device running the F580_CAN0_Receive 
  33          //    code.
  34          //
  35          // 4) Run the code on the Receiver first, then run the code on the Transmitter.
  36          //
  37          // 5) After all the transmissions are complete, the LED will be lit if
  38          //    the transfers were sucessful.
  39          //
  40          // Target:         C8051F580 (Side A of a C8051F580-TB)
  41          // Tool chain:     Raisonance / Keil / SDCC
  42          // Command Line:   None
  43          //
  44          // Release 1.2 / 11 MAR 2010 (GP)
  45          //    -Tested with Raisonance
  46          //
  47          // Release 1.1 / 01 APR 2009 (GP)
  48          //    - Fixed CAN Busy polling to wait for 0b
  49          //
  50          // Release 1.0 / 21 JUL 2008 (ADT)
  51          //    - Initial Revision
  52          //
  53          //-----------------------------------------------------------------------------
  54          // Includes
C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 2   

  55          //-----------------------------------------------------------------------------
  56          
  57          #include <compiler_defs.h>
  58          #include <C8051F580.h>            // SFR declarations
  59          
  60          //-----------------------------------------------------------------------------
  61          // Function Prototypes
  62          //-----------------------------------------------------------------------------
  63          
  64          void OSCILLATOR_Init (void);
  65          void PORT_Init (void);
  66          void CAN0_Init (void);
  67          
  68          void CAN0_TransferMO (U8 obj_num);
  69          
  70          INTERRUPT_PROTO (CAN0_ISR, INTERRUPT_CAN0);
  71          
  72          //-----------------------------------------------------------------------------
  73          // Global Constants
  74          //-----------------------------------------------------------------------------
  75          
  76          #define SYSCLK       24000000          // System clock speed in Hz
  77          
  78          #define MESSAGE_OBJECTS    32          // Number of message objects to use
  79                                                 // Range is 1-32
  80          #define MESSAGE_SIZE        8          // Size in bytes of each CAN message
  81                                                 // Range is 1-8
  82          
  83          #define TX_COMPLETE_MASK  0xFFFFFFFF   // Set this to (2^MESSAGE_OBJECTS - 1)
  84          
  85          
  86          //-----------------------------------------------------------------------------
  87          // Bit Definition Masks
  88          //-----------------------------------------------------------------------------
  89          
  90          // CAN0STAT
  91          #define BOff  0x80                     // Busoff Status
  92          #define EWarn 0x40                     // Warning Status
  93          #define EPass 0x20                     // Error Passive
  94          #define RxOk  0x10                     // Receive Message Successfully
  95          #define TxOk  0x08                     // Transmitted Message Successfully
  96          #define LEC   0x07                     // Last Error Code
  97          
  98          //-----------------------------------------------------------------------------
  99          // Pin Definitions
 100          //-----------------------------------------------------------------------------
 101          
 102          SBIT (LED, SFR_P1, 3);                 // LED = 1 turns on the LED
 103          
 104          //-----------------------------------------------------------------------------
 105          // Global Variables
 106          //-----------------------------------------------------------------------------
 107          
 108          bit CAN_ERROR = 0;                     // 0 = No Errors during transmission
 109                                                 // 1 = Some error(s) occurred
 110          
 111          UU32 CAN_TX_COMPLETE;                  // Bit status register that is updated
 112                                                 // when a TX complete is received for
 113                                                 // a specific message object.  Should be
 114                                                 // equal to TX_COMPLETE_MASK when done
 115          
 116          //-----------------------------------------------------------------------------
C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 3   

 117          // MAIN Routine
 118          //-----------------------------------------------------------------------------
 119          
 120          void main (void)
 121          {
 122   1         U16 iter;                           // Loop counter
 123   1      
 124   1         SFRPAGE = ACTIVE_PAGE;              // Set for PCA0MD
 125   1      
 126   1         PCA0MD &= ~0x40;                    // Disable Watchdog Timer
 127   1      
 128   1         OSCILLATOR_Init ();                 // Initialize oscillator
 129   1         PORT_Init ();                       // Initialize crossbar and GPIO
 130   1         CAN0_Init ();                       // Start CAN peripheral
 131   1      
 132   1         CAN_TX_COMPLETE.U32 = 0x0000;       // Initialize as no messages transmitted
 133   1      
 134   1         EIE2 |= 0x02;                       // Enable CAN interupts
 135   1         EA = 1;                             // Enable global interrupts
 136   1      
 137   1         // CAN0_TransferMO will automatically generate data and send it using the
 138   1         // specified Message Object.  The receive code knows what data to expect
 139   1         // for each Message Object and performs the data verification.
 140   1      
 141   1         LED = 0;
 142   1      
 143   1         for (iter = 0; iter < MESSAGE_OBJECTS; iter++) 
 144   1         {
 145   2            CAN0_TransferMO (iter);
 146   2         }
 147   1      
 148   1         // Check Transmission Requests registers to wait for completion
 149   1         SFRPAGE = CAN0_PAGE;
 150   1         while (CAN0TR1 | CAN0TR2) 
 151   1         {
 152   2            LED = !LED;
 153   2            for (iter = 0; iter < 65000; iter++);   
 154   2         }
 155   1      
 156   1         // Check global variable that all transfers completed without error
 157   1         if (CAN_TX_COMPLETE.U32 != TX_COMPLETE_MASK) 
 158   1         {
 159   2            CAN_ERROR = 1; 
 160   2         }
 161   1      
 162   1         // Once all transmissions are complete, turn off the LED or leave it on 
 163   1         // based on the error status
 164   1      
 165   1         if (CAN_ERROR) 
 166   1         {                                   // If any errors occurred
 167   2            LED = 0;                         // Turn off LED
 168   2         }                       
 169   1         else 
 170   1         {
 171   2            LED = 1;                         // No error, so keep LED on
 172   2         }                       
 173   1      
 174   1         while (1);
 175   1      }
 176          
 177          //-----------------------------------------------------------------------------
 178          // Initialization Subroutines
C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 4   

 179          //-----------------------------------------------------------------------------
 180          
 181          //-----------------------------------------------------------------------------
 182          // OSCILLATOR_Init
 183          //-----------------------------------------------------------------------------
 184          //
 185          // Return Value : None
 186          // Parameters   : None
 187          //
 188          // Initialize the internal oscillator to 24 MHz
 189          //
 190          //-----------------------------------------------------------------------------
 191          void OSCILLATOR_Init (void)
 192          {
 193   1         U8 SFRPAGE_save = SFRPAGE;
 194   1         SFRPAGE = CONFIG_PAGE;
 195   1      
 196   1         OSCICN = 0x87;                      // Set internal oscillator divider to 1
 197   1      
 198   1         SFRPAGE = SFRPAGE_save;
 199   1      }
 200          
 201          //-----------------------------------------------------------------------------
 202          // PORT_Init
 203          //-----------------------------------------------------------------------------
 204          //
 205          // Return Value : None
 206          // Parameters   : None
 207          //
 208          // This function configures the crossbar and ports pins.
 209          //
 210          // P0.6   digital  push-pull        CAN TX
 211          // P0.7   digital  open-drain       CAN RX
 212          //
 213          // P1.3   digital  push-pull        LED
 214          //
 215          //-----------------------------------------------------------------------------
 216          
 217          void PORT_Init (void)
 218          {
 219   1         U8 SFRPAGE_save = SFRPAGE;
 220   1         SFRPAGE  = CONFIG_PAGE;             // Port SFR's on Configuration page
 221   1      
 222   1         P0MDOUT  |= 0x40;                   // P0.6 (CAN0 TX) is push-pull
 223   1         P1MDOUT  |= 0x08;                   // P1.3 (LED) is push-pull
 224   1      
 225   1         XBR0     = 0x02;                    // Enable CAN0 on Crossbar
 226   1         XBR2     = 0x40;                    // Enable Crossbar and weak pull-ups
 227   1      
 228   1         SFRPAGE = SFRPAGE_save;
 229   1      }
 230          
 231          //-----------------------------------------------------------------------------
 232          // CAN0_Init
 233          //-----------------------------------------------------------------------------
 234          //
 235          // Return Value : None
 236          // Parameters   : None
 237          //
 238          // This function initializes the CAN peripheral and all of the message objects
 239          //
 240          // The following settings are chosen for the peripheral and message objects:
C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 5   

 241          //
 242          // CAN Bit Clock : 1 Mbps
 243          // Auto Retransmit : Automatic Retransmission is enabled
 244          // MsgVal        : Set to Valid based on the #define MESSAGE_OBJECTS
 245          // Filtering     : Enabled for all valid message objects
 246          // Message Identifier : 11-bit standard; Each message object is only used by
 247          //                      one message ID and the ID is equal to the object number
 248          // Direction     : All valid message objects are configured for transmit
 249          // End of Buffer : All message objects are treated as separate buffers
 250          //
 251          // The following interrupts are enabled and are handled by CAN0_ISR
 252          //
 253          // Error Interrupts
 254          // Status Change Interrupt
 255          // Transmit Interrupt
 256          //
 257          //-----------------------------------------------------------------------------
 258          
 259          void CAN0_Init (void)
 260          {
 261   1         U8 iter;
 262   1      
 263   1         U8 SFRPAGE_save = SFRPAGE;
 264   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 265   1      
 266   1         CAN0CN |= 0x01;                     // Start Intialization mode
 267   1      
 268   1         //---------Initialize general CAN peripheral settings
 269   1      
 270   1         CAN0CN |= 0x4E;                     // Enable Status, Error, 
 271   1                                             // Module Interrupts
 272   1                                             // Enable access to bit timing register
 273   1      
 274   1         // See the CAN Bit Timing Spreadsheet for how to calculate this value
 275   1         CAN0BT = 0x1402;                    // Based on 24 Mhz CAN clock, set the
 276   1                                             // CAN bit rate to 1 Mbps
 277   1      
 278   1         //---------Initialize settings common to all message objects
 279   1      
 280   1         // Command Mask Register
 281   1         CAN0IF1CM = 0x00F0;                 // Write Operation
 282   1                                             // Transfer ID Mask, MDir, MXtd
 283   1                                             // Transfer ID, Dir, Xtd, MsgVal
 284   1                                             // Transfer Control Bits
 285   1                                             // Don't set TxRqst or transfer data
 286   1      
 287   1         // Mask Registers
 288   1         CAN0IF1M1 = 0x0000;                 // Mask Bits 15-0 not used for filtering
 289   1         CAN0IF1M2 = 0x5FFC;                 // Ignore Extended Identifier for 
 290   1                                             // filtering
 291   1                                             // Used Direction bit for filtering
 292   1                                             // Use ID bits 28-18 for filtering
 293   1      
 294   1         // Arbitration Registers
 295   1         CAN0IF1A1 = 0x0000;                 // 11-bit ID, so lower 16-bits not used
 296   1      
 297   1         // Message Control Registers
 298   1         CAN0IF1MC = 0x0880 | MESSAGE_SIZE;  // Enable Transmit Interrupt
 299   1                                             // Message Object is a Single Message
 300   1                                             // Message Size set by #define
 301   1      
 302   1         //---------Initialize unique settings for each valid message object
C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 6   

 303   1      
 304   1         for (iter = 0; iter < MESSAGE_OBJECTS; iter++)
 305   1         {
 306   2            // For example purposes, set 11-bit identifier based on the message 
 307   2            // object that is used to send it.
 308   2      
 309   2            // Arbitration Registers
 310   2            CAN0IF1A2 = 0xA000 | (iter << 2);  // Set MsgVal to valid
 311   2                                               // Set Direction to write
 312   2                                               // Set 11-bit Identifier to iter
 313   2      
 314   2            CAN0IF1CR = iter;                  // Start command request
 315   2          
 316   2            while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 317   2         }
 318   1      
 319   1         //---------Initialize settings for unused message objects
 320   1      
 321   1         for (iter = MESSAGE_OBJECTS; iter < 32; iter++)
 322   1         {
 323   2            // Set remaining message objects to be Ignored
 324   2            CAN0IF1A2 = 0x0000;              // Set MsgVal to 0 to Ignore
 325   2            CAN0IF1CR = iter;                // Start command request
 326   2          
 327   2            while (CAN0IF1CRH & 0x80) {}     // Poll on Busy bit
 328   2         }
 329   1      
 330   1         CAN0CN &= ~0x41;                    // Return to Normal Mode and disable
 331   1                                             // access to bit timing register
 332   1      
 333   1         SFRPAGE = SFRPAGE_save;
 334   1      }
 335          
 336          //-----------------------------------------------------------------------------
 337          // Supporting Subroutines
 338          //-----------------------------------------------------------------------------
 339          
 340          //-----------------------------------------------------------------------------
 341          // CAN0_TransferMO
 342          //-----------------------------------------------------------------------------
 343          //
 344          // Return Value : None
 345          // Parameters   : U8 obj_num - message object number to send data
 346          //                             range is 0x01 - 0x20
 347          //
 348          // Send data using the message object passed as the parameter. The data
 349          // is generated using the message object number as the seed.
 350          //
 351          //-----------------------------------------------------------------------------
 352          
 353          void CAN0_TransferMO (U8 obj_num)
 354          {
 355   1         // This function assumes that the message object is fully initialized
 356   1         // in CAN0_Init and so all it has to do is fill the data registers and 
 357   1         // initiate transmission
 358   1      
 359   1         U8 SFRPAGE_save = SFRPAGE;
 360   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 361   1      
 362   1         // Initialize all 8 data bytes even though they might not be sent
 363   1         // The number to send was configured earlier by setting Message Control
 364   1      
C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 7   

 365   1         CAN0IF1DA1H = obj_num;              // Initialize data registers based
 366   1         CAN0IF1DA1L = obj_num + 1;          // on message object used
 367   1         CAN0IF1DA2H = obj_num + 2;
 368   1         CAN0IF1DA2L = obj_num + 3;           
 369   1         CAN0IF1DB1H = obj_num + 4;
 370   1         CAN0IF1DB1L = obj_num + 5;
 371   1         CAN0IF1DB2H = obj_num + 6;
 372   1         CAN0IF1DB2L = obj_num + 7;
 373   1      
 374   1         CAN0IF1CM = 0x0087;                 // Set Direction to Write
 375   1                                             // Write TxRqst, all 8 data bytes
 376   1      
 377   1         CAN0IF1CR = obj_num;                // Start command request
 378   1          
 379   1         while (CAN0IF1CRH & 0x80) {}        // Poll on Busy bit
 380   1      
 381   1         SFRPAGE = SFRPAGE_save;
 382   1      }
 383          
 384          
 385          //-----------------------------------------------------------------------------
 386          // Interrupt Service Routines
 387          //-----------------------------------------------------------------------------
 388          
 389          //-----------------------------------------------------------------------------
 390          // CAN0_ISR
 391          //-----------------------------------------------------------------------------
 392          //
 393          // The ISR is triggered upon any CAN errors or upon a complete transmission
 394          //
 395          // If an error occurs, a global counter is updated
 396          //
 397          //-----------------------------------------------------------------------------
 398          
 399          INTERRUPT (CAN0_ISR, INTERRUPT_CAN0)
 400          {
 401   1         // SFRPAGE is set to CAN0_Page automatically when ISR starts
 402   1      
 403   1         U8 status = CAN0STAT;               // Read status, which clears the Status
 404   1                                             // Interrupt bit pending in CAN0IID
 405   1      
 406   1         U8 Interrupt_ID = CAN0IID;          // Read which message object caused
 407   1                                             // the interrupt
 408   1      
 409   1         CAN0IF1CM = 0x0008;                 // Set Command Mask to clear pending 
 410   1                                             // interrupt for the message object
 411   1      
 412   1      
 413   1         CAN0IF1CR = Interrupt_ID;           // Start command request to actually 
 414   1                                             // clear the interrupt
 415   1          
 416   1         while (CAN0IF1CRH & 0x80) {}        // Poll on Busy bit
 417   1      
 418   1         if (status & TxOk)                  // If transmit completed successfully
 419   1         {
 420   2            // Set variable to indicate this message object's transfer completed
 421   2       
 422   2            // Message Object 0 reports as 0x20 in the CAN0IID register, so 
 423   2            // convert it to 0x00
 424   2            if (Interrupt_ID == 0x20) 
 425   2            {
 426   3               Interrupt_ID = 0x00; 
C51 COMPILER V9.60.7.0   MAIN                                                              07/11/2024 15:34:27 PAGE 8   

 427   3            }
 428   2      
 429   2            // Bit-shifting doesn't work with an operator greater than 15, so
 430   2            // account for it 
 431   2            if (Interrupt_ID <= 15) 
 432   2            {
 433   3              CAN_TX_COMPLETE.U32 |= (U16) (0x01 << Interrupt_ID); 
 434   3            }
 435   2            else if (Interrupt_ID <= 0x1F)
 436   2            {
 437   3               CAN_TX_COMPLETE.U16[MSB] |= (U16) (0x01 << (Interrupt_ID - 16)); 
 438   3            }
 439   2         }
 440   1      
 441   1         // If an error occured, simply update the global variable and continue
 442   1         if (status & LEC)                 
 443   1         {
 444   2             // The LEC bits identify the type of error, but those are grouped here
 445   2            if ((status & LEC) != 0x07) 
 446   2            {
 447   3                CAN_ERROR = 1; 
 448   3            }
 449   2         }
 450   1      
 451   1         if (status & BOff)
 452   1         {
 453   2            CAN_ERROR = 1;
 454   2         }
 455   1      
 456   1         if (status & EWarn)
 457   1         {
 458   2            CAN_ERROR = 1;
 459   2         }
 460   1      
 461   1         // Old SFRPAGE is popped off stack when ISR exits
 462   1      }
 463          
 464          //-----------------------------------------------------------------------------
 465          // End Of File
 466          //-----------------------------------------------------------------------------
 467          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    506    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
